set nocompatible

if has("syntax")
    syntax on
endif

filetype plugin indent on

if has("unix")
    " this is default set for terminal,
    " change option if needed in gui
    set shell=/bin/bash
    set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
    colorscheme mycterm
    set mouse=""
endif

function! s:CheckAddSetDefaultVal(var_name, val)
    if !exists(a:var_name)
        exec 'let ' . a:var_name . ' = ' . a:val
    endif
endfunction

"custume font size for you computer screen size
"right font size will make eyes comfortable. no too big or too small
let g:normal_guibg = ["#272822", "#2b3032", "#1b1b1b", "#002b36"]
call s:CheckAddSetDefaultVal("g:default_linux_font_size", 17)
call s:CheckAddSetDefaultVal("g:normal_guibg_idx", 3)

if filereadable(expand("~/.local.vim"))
    source ~/.local.vim
endif

if has("gui_running")
    set guioptions-=m
    set guioptions-=T
    set guioptions-=L
    set mouse=a        "Enable mouse in gui

    if has("win32")
        set guifont=Courier_New:h13:cANSI:qDRAFT
        set fileencodings=
    elseif has("mac")
        set guifont=Monaco:h13
        colorscheme ljyat
    else
        let &guifont='Inconsolata ' . g:default_linux_font_size
        set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
        colorscheme ljyat
    endif
endif

""""""""Special in Gvim"""""""""""""""""""""""
"t_vb when use gvim , you have to set in /etc/vim/gvimrc,
"vimrc is not usefull for gvim
"set vb t_vb=
""""""""""""""""""""""""""""""""""""""""""""""
set t_Co=256
set showmatch        " Show matching brackets.
set incsearch        " Incremental search
set autowrite        " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned
set history=700
set scrolloff=0
set autoread
set ffs=unix,dos,mac
set noswapfile
set updatetime=200
set previewheight=13
set autoindent
set smartindent
set nocindent
set expandtab tabstop=4 shiftwidth=4
set nohlsearch
set smarttab
set linebreak
set number
set nobackup
set backspace=indent,eol,start
set nowrapscan
set winaltkeys=no
set diffopt=filler,vertical
set foldmethod=manual
set complete=.,k

"set statusline
set laststatus=2
set statusline=%!StatusLine()

let c_syntax_for_h = 1
let Tlist_WinWidth = 40
let Tlist_Auto_Open = 0
"global_mode is 0:cscope 1:global
let g:global_mode = 0
let g:tagbar_left = 1
let g:tagbar_sort = 0
let g:tagbar_indent = 4
let html_wrong_comments = 1
"config for taglist
let Tlist_Inc_Winwidth = 0
let NERDTreeWinPos = "right"
let s:searchhistory = 5
let s:SearchList = []
let g:SearchLimit = 5000
let g:SearchPattern = ''

if exists('&breakindent')
    set breakindent
endif

if !exists("s:tmpcscope_files")
    let s:tmpcscope_files = ''
    let s:cscope_tag_dir_list = []
endif

call s:CheckAddSetDefaultVal("s:tmpmatchfilelist", '[]')
call s:CheckAddSetDefaultVal("s:language_mode", "'EN'")
call s:CheckAddSetDefaultVal("s:kernel_mode", "'FALSE'")
call s:CheckAddSetDefaultVal("s:ignore_match_tag", "'EXPORT_SYMBOL'")

if exists("s:PromptGroupID")
    silent! call matchdelete(s:PromptGroupID)
else
    let s:PromptGroupID = -1
endif
if exists("s:PreviewTagID")
    silent! call matchdelete(s:PreviewTagID)
else
    let s:PreviewTagID = -1
endif

if &dict == ''
    let &dict = 'dict'
endif
"=> key maps
nnoremap j gj
nnoremap k gk
nnoremap <F2> :call SwitchTlistTagbar()<CR>
nnoremap <F3> :LjyatNERDTreeOpenBufDir<CR>
nnoremap <F5> :call LjyatSwitchKernelCodeMode()<CR>
nnoremap <F8> :call LjyatSwitchLanguageMode()<CR>
nnoremap <F9> :call LjyatFoldToggle()<CR>
nnoremap <C-F9> :let &foldlevel=&foldlevel-1<CR>
nnoremap <C-F10> :let &foldlevel=&foldlevel+1<CR>
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
nnoremap <M-=> :call IncreaseFontSize()<CR>
nnoremap <M--> :call DecreaseFontSize()<CR>
nnoremap <F4> :LjyatSearchStrCurBuf<CR>
nnoremap <C-s> :LjyatSearchStrCurBuf<CR>

"color set
nmap / <leader>r
nmap n <leader>/
nmap N <leader>?
nmap M :MarkClear<CR><leader>m
nmap S :LjyatSearchStrInFileListCmd<CR>
nmap <leader>] :call LjyatShowTagInPreview(expand("<cword>"))<CR>

nnoremap <Space> <Nop>
nnoremap <M-f> :LjyatSearchFileCmd<CR>
vnoremap <M-r> <ESC>:call LjyatVSearchStrInFiles()<CR>
vnoremap <M-R> <ESC>:call LjyatVSearchStrCurBuf()<CR>

"nnoremap <M-n> :call LoopNormalBG()<CR>
nnoremap <M-[> :cs find c <C-R>=expand("<cword>")<CR><CR>:botright copen<CR>
nnoremap <M-\> :cs find s <C-R>=expand("<cword>")<CR><CR>:botright copen<CR>
nnoremap <M-t> :cs f t
"=> switch windows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <M-2> <C-w>c
nnoremap <M-3> <C-w>v
nnoremap <M-/> :call Prompt_Window_Create("tag")<CR>
"=> switch windows end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"=> normal set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"move
nnoremap <M-j> 3<C-e>
nnoremap <M-k> 3<C-y>
nnoremap <M-c> :MarkClear<CR>
nnoremap <M-q> <C-q>
"copy and paste
vmap <C-c> "+y
vmap m <leader>m
nnoremap <C-v> "+p
nnoremap <M-e> g_
nnoremap <M-a> 0
nnoremap <silent> <M-1> :pc<CR>:lclose<CR>:cclose<CR>
nmap <M-m> <leader>m
nnoremap <M-]> :call LjyatShowTags(expand("<cword>"))<CR>
nmap <M-LeftMouse> <LeftMouse><leader>m
nnoremap <RightMouse> <C-o>
nmap <S-LeftMouse> <LeftMouse>:MarkClear<CR><leader>m
nmap <M-RightMouse> :MarkClear<CR>
nnoremap <M-l> :LjyatShowBookMarks<CR>
nnoremap C :LjyatBookMarkClear<CR>
nnoremap B :LjyatAddBookMark<CR>

"grep -E
nnoremap <M-s> :LjyatSearchStrCmd<CR>
nnoremap <C-p> :cp<CR>
nnoremap <C-n> :cn<CR>
nnoremap <M-p> :cp<CR>
nnoremap <M-n> :cn<CR>
nnoremap <F10> :edit ++ff=dos<CR>

"vim nnoremap
nnoremap <Space>s :LjyatSearchStrCmd<CR>
nmap <Space>m <leader>m
nnoremap <silent> <Space>1 :pc<CR>:lclose<CR>:cclose<CR>
nnoremap <Space>a 0
nnoremap <Space>e g_
nnoremap <Space>q <C-q>
nnoremap <Space>c :MarkClear<CR>
nnoremap <Space>k 3<C-y>
nnoremap <Space>j 3<C-e>
nnoremap <Space>/ :call Prompt_Window_Create("tag")<CR>
nnoremap <Space>3 <C-w>v
nnoremap <Space>2 <C-w>c
nnoremap <Space>t :cs f t
nnoremap <Space>\ :cs find s <C-R>=expand("<cword>")<CR><CR>:botright copen<CR>
nnoremap <Space>[ :cs find c <C-R>=expand("<cword>")<CR><CR>:botright copen<CR>
nnoremap <Space>f :LjyatSearchFileCmd<CR>
nnoremap <Space>] :call LjyatShowTags(expand("<cword>"))<CR>
nmap <Space><RightMouse> :MarkClear<CR>
nmap <Space><LeftMouse> <LeftMouse><leader>m
nnoremap <Space>l :LjyatShowBookMarks<CR>

vnoremap <Space>R <ESC>:call LjyatVSearchStrCurBuf()<CR>
vnoremap <Space>r <ESC>:call LjyatVSearchStrInFiles()<CR>
vnoremap <M-=> :<C-U> call AlignPattern()<CR>

"============= show preview tag config ===========
hi PreviewTagGroup ctermbg=30 ctermfg=11 guifg=Black guibg=Yellow gui=NONE
hi PromptGroup guibg=#8b2500 guifg=NONE

function! s:EchoMoreMsg(msg)
    redraw
    echohl MoreMsg
    echo "   " . a:msg
    echohl None
endfunction

function! s:EchoWarningMsg(msg)
    redraw
    echohl WarningMsg
    echo "   " . a:msg
    echohl None
endfunction

function! StatusLine()
    let m = ''

    if &modified
        let m = '  %m'
    endif

    return "%-f". m ." %w  %{&fenc!=''?&fenc:&enc}  %p%% L%l/%L  %{TagDirs()}%<"
endfunction

function! Trace(prefix)
    put =a:prefix . \"# [\" . expand('%:t') . ': ' . (line('.') + 1) . ']\"' .\");\"
endfunction

function! ShowCurrentMode(timer)
    if s:kernel_mode == "TRUE"
        call s:EchoWarningMsg("Kernel Code Mode")
    else
        call s:EchoWarningMsg( "Normal Code Mode")
    endif
endfunction

function! LjyatSwitchKernelCodeMode()
    let winview = winsaveview()
    let buf_num = bufnr('%')
    if s:kernel_mode == "TRUE"
        bufdo set expandtab tabstop=4 shiftwidth=4
        let s:kernel_mode = "FALSE"
    else
        bufdo set noexpandtab tabstop=8 shiftwidth=8
        let s:kernel_mode = "TRUE"
    endif
    if buf_num != -1
        exe "b" . buf_num
    endif
    call winrestview(winview)
    call timer_start(300, "ShowCurrentMode")
endfunction

function! LjyatSwitchLanguageMode()
    if s:language_mode == "EN"
        AcpDisable
        let s:language_mode = "CH"
        if !has("gui_running")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        if has("win32")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        let &guifont='YaHei Consolas Hybrid ' . g:default_linux_font_size
        call s:EchoWarningMsg("Chinese Mode")
    else
        AcpEnable
        let s:language_mode = "EN"

        if !has("gui_running")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        if has("win32")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        let &guifont='Inconsolata ' . g:default_linux_font_size
        call s:EchoWarningMsg("Englist Mode")
    endif
endfunction

function! LjyatShowCscopeTags(tag)
    if &ft == "java"
        return -1
    endif

    try
        exe "cs f g " . a:tag
    catch /^Vim\%((\a\+)\)\=:E/
        if v:exception =~ "E259"
            call s:EchoWarningMsg("not found tag: " . a:tag)
        elseif v:exception =~ "E567"
            call s:EchoWarningMsg("no cscope connection !!!")
        endif
        return -1
    endtry
endfunction

function! LjyatShowTags(word)
    let word = a:word
    let use_cscope = 0

    call s:EchoMoreMsg(word)

"    silent! let tlist = taglist(word)
"    if empty(tlist)
"        let use_cscope = 1
"    endif
"
"    for item in tlist
"        if item['cmd'] =~ s:ignore_match_tag
"            let use_cscope = 1
"        endif
"    endfor

    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            return
        endif
    else
        " see LjyatShowTagInPreview()
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                return
            endif
        endtry
    endif
    normal zz
endfunction

function! LjyatShowTagInPreview(word)
    let word = a:word
    let use_cscope = 0
    call s:EchoMoreMsg(word)

    silent! let tlist = taglist(word)
    for item in tlist
        if item['cmd'] =~ s:ignore_match_tag
            let use_cscope = 1
        endif
    endfor

    let pw_exist = 0
    let win_cur = winnr()
    silent! wincmd P
    if &previewwindow
        let pw_exist = 1
    else
        silent! pedit
        let win_cur = winnr()
    endif

    wincmd P
    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            exe win_cur . "wincmd w"
            if !pw_exist
                pclose
            endif
            return
        endif
    else
        " some time don't get tag, but taglist() can get, this maybe a bug
        " I have know this problem, because pattern with xxx$ in tags file
        " with dos format, vim can't got it with / or ? , so skip with cscope.
        " Haha, this maybe is ctags problem, it doesn't matter.
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                exe win_cur . "wincmd w"
                if !pw_exist
                    pclose
                endif
                return
            endif
        endtry
    endif
    silent! call matchdelete(s:PreviewTagID)
    let s:PreviewTagID = matchadd('PreviewTagGroup', '\<' . word . '\>')
    if getline('.') =~ '^#define .\+[^\\]$\|;'
        normal zz
    else
        normal zt
    endif

    exe win_cur . "wincmd w"
endfunction
"============= show preview tag config end ===========

function! CompleteCurlyBrackets()
    if (getline('.')[col('.'):] =~'^\s*$')
        put = 'x'
        put = '}'
        normal =%j
        exe "s/x//"
        startinsert!
    else
        let l:col = col('.')
        exe "s/\\%" . l:col . "c{/{}/"
        call cursor('.', l:col + 1)
        startinsert
    endif
endfunction

function! LjyatNERDTreeOpenBufDir()
    call LjyatGotoNormalWin()
    if (exists("t:NERDTreeBufName"))
        if (bufwinnr(t:NERDTreeBufName) != -1)
            execute "silent! NERDTreeClose"
            return
        endif
    endif
    let l:bufname = escape(bufname("%"), ' #')
    execute "silent! NERDTree " . l:bufname
    redraw!
endfunction

"=> cscope set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=1
    set nocst
    set cscopequickfix=c-,s-
    " add any database in current directory
    if filereadable("GTAGS")
        silent! cs add GTAGS
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
endif

function! CleanTmpListFile(cscope_files)
    if a:cscope_files != ''
        return delete(a:cscope_files)
    endif
endfunction

function! TagDirs()
    let dirs = join(s:cscope_tag_dir_list, ",")
    if dirs == ''
        return ''
    else
        return '['.dirs.']'
    endif
endfunction

function! InitTagDirs()
    silent exe "cs kill -1"
    call CleanTmpListFile(s:tmpcscope_files)
    let &tags=''
    let &dict=''
    let s:tmpcscope_files = ''
    let s:tmpmatchfilelist = []
    let s:cscope_tag_dir_list = []
endfunction

function! RemoveTagDirs(rmdirs)
    if a:rmdirs == ''
        call InitTagDirs()
        redraw!
        return
    endif

    let newlist = copy(s:cscope_tag_dir_list)
    for dir in split(a:rmdirs, ",")
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        let rm_tag          = dir . "/tags"
        let rm_cscope       = dir . "/GTAGS"

        if !filereadable(rm_tag) || !filereadable(rm_cscope)
            call s:EchoWarningMsg("empty dir: " . dir)
            redraw!
            return
        endif
        call filter(newlist, 'v:val != dir')
    endfor
    call InitTagDirs()
    if len(newlist) != 0
        call AddTagDirs(join(newlist, ','))
    else
        redraw!
    endif
endfunction

function! AnyOneInTagDirList(dirlist)
    let filelist = copy(s:cscope_tag_dir_list)
    for dir in a:dirlist
        if s:cscope_tag_dir_list != filter(filelist, 'v:val != dir')
            return 1
        endif
    endfor
    return 0
endfunction

function! AddTagDirs(predirs)
    if a:predirs == ''
        call s:EchoWarningMsg("need tag dir")
        return
    endif

    let arglist = []
    for dir in split(a:predirs, ",")
        call add(arglist, substitute(expand(split(dir, "\"")[0]),'/$', '',''))
    endfor
    call uniq(sort(arglist))

    if AnyOneInTagDirList(arglist)
        let addedlist = uniq(sort(arglist + s:cscope_tag_dir_list))
        call InitTagDirs()
    else
        let addedlist = arglist
    endif

    if s:tmpcscope_files == ''
        let s:tmpcscope_files = "/tmp/cscope.files." . getpid()
    endif
    for dir in addedlist
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        if dir == '.'
            let new_tag_path     = "tags"
            let new_cscope_path  = "cscope.out"
            let new_global_path  = "GTAGS"
            let new_dict_path    = "dict"
            let new_cscope_files = "cscope.files"
        else
            let new_cscope_path  = dir . "/cscope.out"
            let new_global_path  = dir . "/GTAGS"
            let new_tag_path     = dir . "/tags"
            let new_dict_path    = dir . "/dict"
            let new_cscope_files = dir . "/cscope.files"
        endif

        if filereadable(new_global_path)
            let new_cscope_path = new_global_path
            set csprg=/usr/bin/gtags-cscope
            let g:global_mode = 1
        elseif filereadable(new_cscope_path)
            let g:global_mode = 0
            set csprg=/usr/bin/cscope
        else
            call s:EchoWarningMsg("No needed file in: " . dir)
            return
        endif

        if filereadable(new_cscope_files)
            if dir == '.'
                silent exe "!cat " . new_cscope_files . ' >> ' . s:tmpcscope_files
            else
                silent exe "!cat " . new_cscope_files . "|sed 's:^:" . dir . "/:' >> " . s:tmpcscope_files
            endif
        endif

        if len(s:cscope_tag_dir_list) == 0
            let &tags = new_tag_path
            let &dict = new_dict_path
        else
            let &tags = &tags . "," . new_tag_path
            let &dict = &dict . "," . new_dict_path
        endif
        call add(s:cscope_tag_dir_list, dir)

        if dir == '.'
            let dir = ''
        else
            "cscope prepath always need a '/'
            if stridx(dir, "/") == -1
                let dir = substitute(dir, '^', './','')
            endif
        endif
        if g:global_mode == 0
            silent! exe "cscope add " . new_cscope_path . " " . dir
        else
            let $GTAGSROOT = getcwd() . '/'. dir
            let $GTAGSDBPATH = getcwd() . '/'. dir
            silent! exe "cscope add " . new_cscope_path
        endif
    endfor
    redraw!
endfunction

function! LjyatSearchTags()
    echohl Question
    let pattern = input("  Search tag: ")
    echohl None

    if pattern == ""
        return
    endif

    try
        execute "tj /" . pattern
    catch /^Vim\%((\a\+)\)\=:E/
        call s:EchoWarningMsg("not found tag: " . pattern)
    endtry
endfunction

function! Arggrep(pattern_arg)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern_arg == ''
        call s:EchoWarningMsg("pattern is null")
        return
    endif

    execute "silent! MarkClear|silent! Mark " . a:pattern_arg

    let pattern = "'" . a:pattern_arg . "'"
    let real_cmd = 'xargs grep -a -n -H -E ' . pattern . ' < ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching String ". pattern . " ...")

    let match_string = system(real_cmd)
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let old = ''
    let new = ''
    let match_files = ''
    for line in split(match_string, '\n')
        let new = substitute(line, ':.*', '', 'g')
        if old != new
            let match_files = match_files . " " . new
        endif
        let old = new
    endfor
    exec "args " . match_files

    let ef = &errorformat
    set efm=%f:%l:%m

    let matchlist = split(match_string, '\n')
    let matchlen = len(matchlist)
    let g:SearchPattern = pattern
    execute "silent! cexpr matchlist"
    botright copen
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchFunctionCaller()
    let pattern = expand("<cword>")
    if pattern == ""
        return
    endif

    let pattern = '=\s*\<' . pattern . '\>|\<' . pattern . '\>\s*\('
    let pattern = "'" . pattern . "'"
    let real_cmd = 'xargs grep  -a -n -H -E ' . pattern . ' < ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching called " . pattern . " ...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    let g:SearchPattern = pattern
    execute "silent! cexpr match_string"
    botright copen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchStr(pattern, cscope_files)
    if !filereadable(a:cscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern == ""
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'xargs grep -a -n -H -E ' . ((&ignorecase == 1)? " -i ": " ")  . pattern . ' < ' . a:cscope_files
    call s:EchoMoreMsg("Searching String " . pattern . " ...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let matchlist = split(match_string, '\n')
    let filterlist = []
    for item in matchlist
        if matchstr(split(item, ':')[2], '^\s*//') == ""
            call add(filterlist, item)
        endif
    endfor

    let matchlen = len(filterlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let match_string = join(filterlist, "\n")
    let ef = &errorformat
    set efm=%f:%l:%m

    let g:SearchPattern = pattern
    execute "silent! cexpr match_string"
    botright copen
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchStrCmd()
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    echohl Question
    let pattern = input("  Search str: ", escape(expand("<cword>"), '#'))
    echohl None
    call LjyatSearchStr(pattern, s:tmpcscope_files)
endfunction

function! Argfind(pattern)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern == ''
        echo "   pattern is null"
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ") . pattern . ' ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching file " . pattern . " ...")
    let match_files = system(real_cmd, " ")
    if match_files == ""
        call s:EchoWarningMsg("No match file: " . pattern)
        return
    endif

    let args_file = ""
    for line in split(match_files, '\n')
        let args_file = args_file . " " . line
    endfor
    exec "args " . args_file
    let ef = &errorformat
    set efm=%f

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)

    let g:SearchPattern = pattern
    execute "silent! cexpr matchlist"
    botright copen
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchStrInFileList(pattern, filelist)
    if empty(a:filelist)
        call s:EchoWarningMsg("tmpmatchfilelist is empty")
        return
    endif

    let tmplistfile = "/tmp/cscope.matchlist." . getpid()
    call writefile(a:filelist, tmplistfile)
    call LjyatSearchStr(a:pattern, tmplistfile)
    call delete(tmplistfile)
endfunction

function! LjyatSearchStrInFileListCmd()
    if empty(s:tmpmatchfilelist)
        call s:EchoWarningMsg("matchfilelist is empty")
        return
    endif
    echohl Question
    let pattern = input("  Search str in match file: ", escape(expand("<cword>"), '#'))
    echohl None
    call LjyatSearchStrInFileList(pattern, s:tmpmatchfilelist)
endfunction

function! LjyatSearchFile(pattern, cscope_files)
    if !filereadable(a:cscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return []
    endif

    if a:pattern == ""
        return []
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ")  . pattern . ' ' . a:cscope_files
    call s:EchoMoreMsg("Searching file " . pattern . " ...")

    let match_files = system(real_cmd)
    if match_files == ""
        call s:EchoWarningMsg("No match files: " . pattern)
        return []
    endif

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return []
    endif

    let ef = &errorformat
    set efm=%f

    let g:SearchPattern = pattern
    execute "silent! cexpr match_files"
    botright copen
    let &errorformat = ef
    redraw!
    return matchlist
endfunction

function! LjyatSearchFileCmd()
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    echohl Question
    let pattern = input("  Search file: ")
    echohl None

    if pattern == ""
        return
    endif

    let s:tmpmatchfilelist = LjyatSearchFile(pattern, s:tmpcscope_files)
endfunction

function! LjyatGotoNormalWin()
    let win_count = winnr('$') "loop back to this window again
    let win_pos = 0
    while &buftype != ""
        if win_pos == win_count
            return -1
        endif
        let win_pos = win_pos + 1
        wincmd w
    endwhile
    return 0
endfunction

function! LjyatGotoWin(name)
    let winnum = bufwinnr(a:name)
    if winnum != -1
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return 0
    else
        return -1
    endif
endfunction

"<C-s> not work in terminal. so should use <F4>
function! LjyatSearchStrCurBuf()
    call LjyatGotoNormalWin()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    echohl Question

    if len(s:SearchList) == 0
        let pattern = input("  Search cur-str: ", expand("<cword>"))
        if match(pattern, "\|")  != -1
            call insert(s:SearchList, pattern)
        endif
    else
        let outputlist = []
        call add(outputlist, '0. ' . expand("<cword>"))
        let idx = 1
        for item in s:SearchList
            let outputitem = idx . '. ' . item
            call add(outputlist, outputitem)
            let idx += 1
        endfor

        let l:sel_idx = inputlist(outputlist)
        if l:sel_idx == 0
            let pattern = input("  Search cur-str: ", expand("<cword>"))
        else
            let pattern = input("  Search cur-str: ", s:SearchList[l:sel_idx - 1])
        endif
        if match(pattern, "\|")  != -1
            call insert(s:SearchList, pattern)
            let s:SearchList = uniq(copy(s:SearchList))
            if len(s:SearchList) > s:searchhistory
                call remove(s:SearchList, -1)
            endif
        endif
    endif

    echohl None

    if pattern == ""
        return
    endif

    let g:SearchPattern = pattern
    let pattern = "/" . pattern . "/"
    let real_cmd = "vimgrep " . pattern . " %"
    call s:EchoMoreMsg("Searching cur-str " . pattern . " ...")

    execute "silent! " . real_cmd
    botright copen
    redraw!
endfunction

function! LjyatVSearchStrCurBuf()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    let old = @"
    exe "normal! gvy"
    let pattern = @"
    let @" = old

    let pattern = input("  Search cur-str: ", pattern)

    let g:SearchPattern = pattern
    let pattern = "/" . pattern . "/"
    let real_cmd = "vimgrep " . pattern . " %"

    execute "silent! " . real_cmd
    botright copen
    redraw!
endfunction

function! LjyatVSearchStrInFiles()
    let old = @"
    exe "normal! gvy"
    let pattern = @"
    call LjyatSearchStr(pattern, s:tmpcscope_files)
    let @" = old
    redraw!
endfunction

function! SwitchTlistTagbar()
    let tagbarwinnr = bufwinnr("__Tagbar__")
    let tlistwinnr = bufwinnr(g:TagList_title)

    if tagbarwinnr != -1
        TagbarToggle
        if tlistwinnr == -1
            Tlist
        endif
    elseif tlistwinnr != -1
        Tlist
        if tagbarwinnr == -1
            TagbarToggle
        endif
    else
        Tlist
    endif
endfunction

function! IncreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size += 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size += 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! DecreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size -= 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size -= 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! CreateTable(linenum, col)
    let c=a:col
    let l = a:linenum
    let empty_str = " "
    while c > 0
        let empty_str = empty_str . " "
        let c = c - 1
    endwhile

    while l > 0
        put =empty_str
        let l = l - 1
    endwhile
endfunction

let s:mark_index = 0
let s:mark_list=[]
function! LjyatAddBookMark()
    let s:mark_tag_{s:mark_index} = bufname('%'). ":". line('.') .":".getline('.')
    let s:mark_list+=[s:mark_tag_{s:mark_index}]
    let s:mark_index+=1
endfunction

function! LjyatShowBookMarks()
    if s:mark_index == 0
        call s:EchoWarningMsg("No marks ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m
    exe "cgetexpr s:mark_list"
    exe "botright copen"
    let &errorformat = ef
endfunction

function! LjyatUpdateGTAGS(file)
    if len(s:cscope_tag_dir_list) == 0 || g:global_mode == 0
        return
    endif
    let curdir = getcwd()
    let dir = fnamemodify(a:file, ":p:h")
    let name = fnamemodify(a:file, ":t")
    exe 'silent !cd ' . dir . ' && global --single-update  ' . name
endfunction

function! LjyatBookMarkClear()
    let s:mark_index = 0
    let s:mark_list=[]
    execute "cclose"
endfunction

function! LoopNormalBG()
    let g:normal_guibg_idx = g:normal_guibg_idx % len(g:normal_guibg)   
    exec "hi Normal guibg=" . g:normal_guibg[g:normal_guibg_idx]
    let g:normal_guibg_idx += 1
endfunction

function! LjyatFoldToggle()
    if &foldcolumn == 0
        let &foldcolumn = 4
        let &foldmethod = 'syntax'
        let &foldlevel = 2
        set foldenable
    else
        let &foldcolumn = 0
        let &foldmethod = 'manual'
        let &foldlevel = 99
        set nofoldenable
    endif
endfunction

function! AlignPattern()
    let input = input("  Align: ", '=')
    let str = escape(input, '.')
    let line_s = line("'<")
    let line_e = line("'>")
    let max = 0
    let arr = {}
    let l = line_s
    while l <= line_e
        let line = getline(l)
        if matchstr(line, str) == ''
            let l += 1
            continue
        endif
        let arr[l] = matchlist(getline(l), '\(^.*\)' . str . '\(.*\)')
        let len = strlen(arr[l][1])
        let max = (len > max ? len : max)
        let l += 1
    endwhile

    let strSpace = CreateSpaces(max)
    for [key, value] in items(arr)
        call setline(key, value[1].strpart(strSpace, 0, max-strlen(value[1])) . input . value[2])
    endfor
endfunction

function! CreateSpaces(n)
    let s = ''
    if a:n < 0
        return s
    endif
    for i in range(a:n)
        let s .= ' '
    endfor
    return s
endfunction

let g:Prompt_Title = "__File_List__"
let s:str_in = ''
let s:type = ''
let s:prompt_prefix_min = 3
let s:prompt_height= 15
let s:prompt_tagwidth = 15
let s:prompt_taglist = []
let s:prompt_keyloop = 0
let s:prompt_match_len = 0
let s:prompt_timer = 0
let s:prompt_keywait = 200
let s:prompt_register_mark = 0

function! PromptSearchTrigger(str_in, type)
    if PromptGetPrefixMin(a:str_in, a:type)
        call s:TimerStop(s:prompt_timer)
        let s:prompt_timer = timer_start(s:prompt_keywait, "s:PromptTimerHandler")
    endif
endfunction

function! PromptGetPrefixMin(str_in, type)
    let s:prompt_prefix_min = 3
    if a:type == "tag"
        return (len(a:str_in) >= s:prompt_prefix_min)?1:0
    elseif a:type == "file"
        if a:str_in =~ "^f: "
            return (len(a:str_in) >= s:prompt_prefix_min + 3)?1:0
        else
            return (len(a:str_in) >= s:prompt_prefix_min)?1:0
        endif
    endif
endfunction

function! PromptClose()
    call s:Prompt_InputClear()
    if LjyatGotoWin(g:Prompt_Title) == 0
        close
    endif
    let s:prompt_keyloop = 0
    let s:prompt_match_len = 0
    let s:prompt_register_mark = 0
    silent! call matchdelete(s:PromptGroupID)
    call LjyatGotoNormalWin()
    redraw!
endfunction

function! PromptJumpTag(line)
    if a:line > s:prompt_match_len
        return
    endif

    call LjyatGotoNormalWin()
    if bufname('%') == g:Prompt_Title
        exe "wincmd p"
    endif
    let filename = s:prompt_taglist[a:line - 1]["filename"]
    let cmd = s:prompt_taglist[a:line - 1]["cmd"]
    if buflisted(filename)
        exe "b ". filename
    else
        exe "edit " . filename
    endif
    let scan_op = &wrapscan
    let magic_op = &magic
    setlocal wrapscan nomagic
    exe cmd
    setlocal nowrapscan magic
endfunction

function! PromptJumpFile(file)
    if a:file == ""
        return
    endif

    call LjyatGotoNormalWin()
    if bufname('%') == g:Prompt_Title
        exe "wincmd p"
    endif
    if buflisted(a:file)
        try
            exe "b ". a:file
            return
        catch /^Vim\%((\a\+)\)\=:E/
        endtry
    endif
    exe "edit " . a:file
endfunction

function! s:PromptDelLastChar(str_in, type)
    if a:type == "file" && a:str_in == "f: "
        return ""
    endif

    return a:str_in[:-2]
endfunction

function! s:CtrlKeyHandler(key, type)
    if a:key == "\<Bs>" || a:key == "\<C-Bs>" || a:key == "\<M-Bs>" || a:key == "\<S-Bs>"
        if len(s:Prompt_getInput()) > 0
            call s:Prompt_InputInit(s:PromptDelLastChar(s:Prompt_getInput(), a:type))
            call PromptSearchTrigger(s:Prompt_getInput(), a:type)
        endif
    elseif a:key == 18 "Ctrl-R register
        let s:prompt_register_mark = 1
    elseif a:key == "\<MiddleMouse>"
        call s:Prompt_InputAppend(getreg('*'))
        call s:PromptUpdateMsg(a:type)
    elseif a:key == "\<MiddleRelease>"
        call PromptSearchTrigger(s:Prompt_getInput(), a:type)
"    elseif a:key == 23 "Ctrl-R CTRL_W current word
"        let s:prompt_register_mark = 0
"        if LjyatGotoNormalWin() != 0
"            return
"        endif
"
"        let s:str_in = s:str_in . expand('<cword>')
"        call LjyatGotoWin(g:Prompt_Title)
"        call PromptSearchTrigger(s:str_in, a:type)
    elseif a:key == 27 "<Esc>
        call PromptClose()
        return
    elseif a:key == 0x0d "CR
        if a:type == "file"
            call PromptJumpFile(getline('.'))
        elseif a:type == "tag"
            call PromptJumpTag(line('.'))
        endif
        call PromptClose()
        return
    elseif a:key == 0x17 "CTRL_W
        if a:type == "file" && len(s:Prompt_getInput()) > 3
            call s:Prompt_InputInit("f: ")
        else
            call s:Prompt_InputClear()
        endif
        call s:PromptUpdateMsg(a:type)
    elseif a:key == "\<Down>" || a:key == 14 || a:key == 238
        normal j
    elseif a:key == "\<Up>" || a:key == 16 || a:key == 240
        normal k
    elseif a:key == "\<PageDown>" || a:key == 6 || a:key == 4
        normal 10j
    elseif a:key == "\<PageUp>" || a:key == 2 || a:key == 21
        normal 10k
    endif
    call s:PromptUpdateMsg(a:type)
endfunction

function! s:PatternNumInFile(tag, file, ignorecase)
    if !filereadable(a:file)
        return 0
    endif
    let igcase = ""
    if a:ignorecase
        let igcase = " -i "
    endif
    return system('grep -a -h -E '. igcase . a:tag . ' ' . a:file . " |wc -l")
endfunction

function! s:PatternNumInDictDirs(tag, dirs)
    let tag_num = 0
    for dir in a:dirs
        let tag_num = tag_num + s:PatternNumInFile(a:tag, dir.'/dict', &ignorecase)
    endfor
    return tag_num
endfunction

function! s:Prompt_InputInit(str)
    let s:str_in = a:str
endfunction

function! s:Prompt_InputClear()
    let s:str_in = ''
endfunction

function! s:Prompt_InputAppend(str)
    let s:str_in = s:str_in . substitute(a:str, '[^0-9A-Za-z-_.:+\\]\+.*','','g')
endfunction

function! s:Prompt_getInput()
    return s:str_in
endfunction

function! s:Prompt_SearchTag(tag)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    sil! exe '%d _'

    let s:prompt_match_len = s:PatternNumInDictDirs(a:tag, s:cscope_tag_dir_list)
    if s:prompt_match_len > g:SearchLimit
        return
    endif

    let s:prompt_taglist = taglist(a:tag)
    let showtags = ""

    normal! gg
    let s:prompt_match_len = 0
    let idx = 0
    for tagitem in s:prompt_taglist
        let tagname = tagitem["name"] . CreateSpaces(s:prompt_tagwidth - len(tagitem["name"]))
        let showtags = tagitem["kind"] . "  " . tagname . "    " . tagitem["filename"] . "  " . substitute(substitute(tagitem["cmd"], "/^","",""),"$/","","")
        if idx == 0
            0put =showtags
        else
            put =showtags
        endif
        let s:prompt_match_len = s:prompt_match_len + 1
        if s:prompt_match_len > g:SearchLimit
            sil! exe '%d _'
            return
        endif
        let idx += 1
    endfor
    normal! gg

    silent! call matchdelete(s:PromptGroupID)
    let s:PromptGroupID = matchadd('PromptGroup', a:tag. '\c')
endfunction

function! s:Prompt_SearchFile(pattern, cscope_files)
    sil! exe '%d _'
    let pattern = a:pattern
    let real_cmd = ''
    if a:pattern =~ "^f: "
        let pattern = a:pattern[3:]
        let filter_cmd = 'substitute(v:val, ".*/", "","") =~? pattern'
        let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ") . a:pattern[3:] . ' ' . a:cscope_files
    else
        let filter_cmd = 'v:val =~? a:pattern'
        let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ") . a:pattern . ' ' . a:cscope_files
    endif

    let match_files = system(real_cmd)
    let matchlist = split(match_files, '\n')
    let s:prompt_match_len = len(matchlist)
    silent! call matchdelete(s:PromptGroupID)
    let s:PromptGroupID = matchadd('PromptGroup', pattern . '\c')
    normal! gg
    0put =matchlist
    normal! gg
endfunction

function! s:PromptUpdateMsg(type)
    echon ""
    if s:prompt_match_len > g:SearchLimit
        redr | echoh MoreMsg | echon a:type .'   [>' . g:SearchLimit.'] >>> ' . s:Prompt_getInput() | echoh None
    else
        redr | echoh MoreMsg | echon a:type . '   ['.s:prompt_match_len.'] >>> ' . s:Prompt_getInput() | echoh None
    endif
endfunction

function! s:PromptTimerHandler(timer)
    if s:type == "file"
        call s:Prompt_SearchFile(s:Prompt_getInput(), s:tmpcscope_files)
    elseif s:type == "tag"
        call s:Prompt_SearchTag(s:Prompt_getInput())
    else
        call EchoWarningMsg("no support type search")
        call PromptClose()
        return
    endif
    call s:PromptUpdateMsg(s:type)
endfunction

function! s:TimerStop(timerid)
    if v:version >= 800
        call timer_stopall()
    else
        call timer_stop(a:timerid)
    endif
endfunction

function! s:PromptGetCurrentFileName()
    if LjyatGotoNormalWin() != 0
        call LjyatGotoWin(g:Prompt_Title)
        return ''
    endif
    let filename = getreg("%")
    if filename != ''
        let filename = system("basename ". filename)
        if filename != ''
            let filename = split(filename, '\.')[0]
        endif
    endif
    call LjyatGotoWin(g:Prompt_Title)
    return filename
endfunction

function! s:PromptGetCurrentTagWord()
    let word = ''
    if LjyatGotoNormalWin() != 0
        call LjyatGotoWin(g:Prompt_Title)
        return word
    endif

    if &ft == 'cpp'
        setlocal iskeyword+=:
        let word = expand("<cword>")
        setlocal iskeyword-=:
    else
        let word = expand("<cword>")
    endif
    call LjyatGotoWin(g:Prompt_Title)
    return word
endfunction

function! s:Prompt_Window_Init(type)
    setlocal noreadonly
    silent! setlocal nowrap
    silent! setlocal nobuflisted
    silent! setlocal number
    silent! setlocal ma cul
    silent! setlocal buftype=nofile
    mapclear <buffer>

    let s:type = a:type
    let s:prompt_keyloop = 1
    sil! exe '%d _'
    call s:Prompt_InputClear()
    if a:type == "file"
        call s:Prompt_InputInit('f: ')
        call s:Prompt_InputAppend(s:PromptGetCurrentFileName())
    elseif a:type == "tag"
        call s:Prompt_InputAppend(s:PromptGetCurrentTagWord())
    endif

    if len(s:Prompt_getInput()) >= s:prompt_prefix_min
        call s:PromptUpdateMsg(a:type)
        call PromptSearchTrigger(s:Prompt_getInput(), a:type)
    else
        call s:Prompt_InputClear()
    endif

    call s:PromptUpdateMsg(a:type)
    while s:prompt_keyloop
        let nr = getchar()
        call s:TimerStop(s:prompt_timer)
        if (nr >= 0x20) &&  nr <= 0x7f "normal char
            let c = nr2char(nr)
            if s:prompt_register_mark
                call s:Prompt_InputAppend(getreg(c))
            else
                call s:Prompt_InputAppend(c)
            endif
            call s:PromptUpdateMsg(a:type)
            call PromptSearchTrigger(s:Prompt_getInput(), a:type)
        else
            call s:CtrlKeyHandler(nr, a:type)
        en
    endwhile
endfunction

function! Prompt_Window_Create(type)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if LjyatGotoWin(g:Prompt_Title) == 0
        return
    endif

    exe 'silent! keepalt botright ' . s:prompt_height . ' split +buffer ' . g:Prompt_Title
    call s:Prompt_Window_Init(a:type)
endfunction

command! -nargs=1 Argfind call Argfind(<f-args>)
command! -nargs=+ -complete=dir A call AddTagDirs('<f-args>')
command! -nargs=* -complete=dir R call RemoveTagDirs('<f-args>')
command! LjyatNERDTreeOpenBufDir call LjyatNERDTreeOpenBufDir()
command! -nargs=1 Arggrep call Arggrep(<f-args>)
command! LjyatSearchStrCmd call LjyatSearchStrCmd()
command! LjyatSearchFunctionCaller call LjyatSearchFunctionCaller()
command! LjyatSearchFileCmd call Prompt_Window_Create("file")
command! LjyatSearchStrInFileListCmd call LjyatSearchStrInFileListCmd()
command! LjyatVSearchStrCurBuf call LjyatVSearchStrCurBuf()
command! LjyatSearchStrCurBuf call LjyatSearchStrCurBuf()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatShowBookMarks call LjyatShowBookMarks()
command! LjyatBookMarkClear call LjyatBookMarkClear()
command! -nargs=+ CreateTable call CreateTable(<f-args>)

" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup LjyatAutoCmds
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
    autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType htm set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType css set omnifunc=csscomplete#CompleteCSS
    autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
    autocmd FileType php set omnifunc=phpcomplete#CompletePHP
    autocmd FileType c,cpp,java,cs set omnifunc=ccomplete#Complete
    autocmd FileType make setlocal iskeyword+=-
    autocmd FileType qf setlocal wrap nu
    autocmd VimEnter * call AddTagDirs('.')

    autocmd VimLeave * call CleanTmpListFile(s:tmpcscope_files)
    autocmd BufWritePost * call LjyatUpdateGTAGS(bufname("%"))
    autocmd BufNewFile,BufRead *.aidl setf java
    autocmd BufNewFile,BufRead *.hal setf c
augroup end
" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" => Set mark color
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
hi MarkWord1  ctermbg=Cyan     ctermfg=Black  guibg=#8CCBEA    guifg=Black
hi MarkWord2  ctermbg=Green    ctermfg=Black  guibg=#A4E57E    guifg=Black
hi MarkWord3  ctermbg=Yellow   ctermfg=Black  guibg=#FFDB72    guifg=Black
hi MarkWord4  ctermbg=Red      ctermfg=Black  guibg=#FF7272    guifg=Black
hi MarkWord5  ctermbg=Magenta  ctermfg=Black  guibg=#FFB3FF    guifg=Black
hi MarkWord6  ctermbg=Blue     ctermfg=Black  guibg=#9999FF    guifg=Black

call LoopNormalBG()
if filereadable('projs.vim')
    source projs.vim
endif
