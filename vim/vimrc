set nocompatible

if has("syntax")
    syntax on
endif

filetype plugin indent on

if has("unix")
    " this is default set for terminal,
    " change option if needed in gui
    set shell=/bin/bash
    colorscheme mycterm
    set mouse=""
endif

function! OpenQuickFixWin(h)
    exe "botright copen " . a:h
endfunction

function! s:CheckAddSetDefaultVal(var_name, val)
    if !exists(a:var_name)
        exec 'let ' . a:var_name . ' = ' . a:val
    endif
endfunction

let g:FontName = 'Inconsolata Medium'

"custume font size for you computer screen size
"right font size will make eyes comfortable. no too big or too small
let g:normal_guibg = ["#272822", "#2b3032", "#1b1b1b", "#002b36"]
call s:CheckAddSetDefaultVal("g:default_linux_font_size", 15)
call s:CheckAddSetDefaultVal("g:normal_guibg_idx", 2)

if filereadable(expand("~/.local.vim"))
    source ~/.local.vim
endif


if has("gui_running")
    set guioptions-=m
    set guioptions-=T
    set guioptions-=L
    set mouse=a        "Enable mouse in gui

    if has("win32")
        set guifont=Consolas:h13:cANSI:qDRAFT
    elseif has("mac")
        set guifont=Monaco:h13
    else
        let &guifont=g:FontName . ' ' . g:default_linux_font_size
        set linespace=0
    endif
    colorscheme light
endif

""""""""Special in Gvim"""""""""""""""""""""""
"t_vb when use gvim , you have to set in /etc/vim/gvimrc,
"vimrc is not usefull for gvim
"set vb t_vb=
""""""""""""""""""""""""""""""""""""""""""""""
set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
set encoding=utf-8
set t_Co=256
set showmatch        " Show matching brackets.
set incsearch        " Incremental search
set autowrite        " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned
set history=700
set scrolloff=0
set autoread
set ffs=unix,dos,mac
set noswapfile
set updatetime=200
set previewheight=13
set autoindent
set smartindent
set nocindent
set cino=l1
set expandtab tabstop=4 shiftwidth=4
set nohlsearch
set smarttab
set linebreak
set number
set nobackup
set backspace=indent,eol,start
set nowrapscan
set nowrap
set winaltkeys=no
set diffopt=filler,vertical
set foldmethod=manual
set complete=.,k

"set statusline
set laststatus=2
set statusline=%!StatusLine()

let g:search_ignore_comment=0
let c_syntax_for_h = 1
let Tlist_WinWidth = 33
let Tlist_Auto_Open = 0
"global_mode is 0:cscope 1:global
let g:global_mode = 0
let g:tagbar_left = 1
let g:tagbar_sort = 0
let g:tagbar_indent = 4
let html_wrong_comments = 1
"config for taglist
let Tlist_Inc_Winwidth = 0
let NERDTreeWinPos = "right"
let s:searchhistory = 5
let g:SearchLimit = 5000
let g:SearchPattern = ''
let g:QFlistPattern = ''

if exists('&breakindent')
    set breakindent
endif

if !exists("s:tmpcscope_files")
    let s:tmpcscope_files = ''
    let s:cscope_tag_dir_list = []
endif

call s:CheckAddSetDefaultVal("s:tmpmatchfilelist", '[]')
call s:CheckAddSetDefaultVal("s:language_mode", "'EN'")
call s:CheckAddSetDefaultVal("s:kernel_mode", "'FALSE'")
call s:CheckAddSetDefaultVal("s:ignore_match_tag", "'EXPORT_SYMBOL'")

if exists("s:PromptGroupID")
    silent! call matchdelete(s:PromptGroupID)
    silent! call matchdelete(s:PromptNormalGroupID)
else
    let s:PromptGroupID = -1
    let s:PromptNormalGroupID = -1
endif
if exists("s:PreviewTagID")
    silent! call matchdelete(s:PreviewTagID)
else
    let s:PreviewTagID = -1
endif

if &dict == ''
    let &dict = 'dict'
endif
"=> key maps
nnoremap <silent> j gj
nnoremap <silent> k gk
nnoremap <silent> <F2> :call SwitchTlistTagbar()<CR>
nnoremap <silent> <F3> :LjyatNERDTreeOpenBufDir<CR>
nnoremap <silent> <F5> :call LjyatSwitchKernelCodeMode()<CR>
nnoremap <silent> <F8> :call LjyatSwitchLanguageMode()<CR>
nnoremap <silent> <F9> :call LjyatFoldToggle()<CR>
nnoremap <silent> <C-F9> :let &foldlevel=&foldlevel-1<CR>
nnoremap <silent> <C-F10> :let &foldlevel=&foldlevel+1<CR>
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
nnoremap <silent> <M-=> :call IncreaseFontSize()<CR>
nnoremap <silent> <M--> :call DecreaseFontSize()<CR>
nnoremap <silent> <C-s> :LjyatSearchStrCurBuf<CR>
nnoremap <silent> <F4> :LjyatSearchStrCurBuf<CR>
"nnoremap <silent> <C-s> :call Prompt_Window_Create("cur-str")<CR>

"color set
nmap / <leader>r
nmap n <leader>/
nmap N <leader>?
nmap M :MarkClear<CR><leader>m
nmap S :LjyatSearchStrInFileListCmd<CR>
nmap F :call LjyatQFListFilterFile(getqflist(), input("qflist filter: "))<CR>
nmap <leader>] :call LjyatShowTagInPreview(LjyatGetJumpTag())<CR>

nnoremap <silent> <Space> <Nop>
nnoremap <silent> <silent> <M-f> :LjyatSearchFileCmd<CR>
vnoremap <M-r> <ESC>:call LjyatVSearchStrInFiles()<CR>
vnoremap <M-R> <ESC>:call LjyatVSearchStrCurBuf()<CR>

"nnoremap <M-n> :call LoopNormalBG()<CR>
nnoremap <silent> <M-[> :cs find c <C-R>=expand("<cword>")<CR><CR>:call OpenQuickFixWin(&window/2)<CR>
nnoremap <silent> <M-\> :cs find s <C-R>=expand("<cword>")<CR><CR>:call OpenQuickFixWin(&window/2)<CR>
nnoremap <silent> <M-t> :cs f t
"=> switch windows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <silent> <M-2> <C-w>c
nnoremap <silent> <M-3> <C-w>v
nnoremap <silent> <M-/> :call Prompt_Window_Create("tag")<CR>
"=> switch windows end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"=> normal set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"move
nnoremap <silent> <M-j> 3<C-e>
nnoremap <silent> <M-k> 3<C-y>
nnoremap <silent> <M-c> :call g:DoMarkClear()<CR>
nnoremap <silent> <M-q> <C-q>
"copy and paste
vmap <C-c> "+y
vmap m <leader>m
nnoremap <silent> <C-v> "+p
nnoremap <silent> <M-e> g_
nnoremap <silent> <M-a> 0
nnoremap <silent> <silent> <M-1> :call ClosePreAndQuickWin()<CR>
nmap <M-m> <leader>m
nnoremap <silent> <M-]> :call LjyatShowTags(LjyatGetJumpTag(), 0)<CR>
nnoremap <silent> <M-.> :call LjyatShowTags(LjyatGetJumpTag(), 1)<CR>
nmap <M-LeftMouse> <LeftMouse><leader>m
nnoremap <silent> <RightMouse> <C-o>
nmap <S-LeftMouse> <LeftMouse>:MarkClear<CR><leader>m
nmap <M-RightMouse> :call g:DoMarkClear()<CR>
nnoremap <silent> <M-l> :call LjyatSearchClassParent()<CR>
nnoremap <silent> C :LjyatBookMarkClear<CR>
nnoremap <silent> B :LjyatAddBookMark<CR>

"grep -E
nnoremap <silent> <M-s> :LjyatSearchStrCmd<CR>
nnoremap <silent> <C-p> :cp<CR>zz
nnoremap <silent> <C-n> :cn<CR>zz
nnoremap <silent> <M-p> :cp<CR>zz
nnoremap <silent> <M-n> :cn<CR>zz
nnoremap <silent> <F10> :edit ++ff=dos<CR>

"vim nnoremap
nnoremap <silent> <Space>s :LjyatSearchStrCmd<CR>
nmap <Space>m <leader>m
nnoremap <silent> <silent> <Space>1 :call ClosePreAndQuickWin()<CR>
nnoremap <silent> <Space>a 0
nnoremap <silent> <Space>e g_
nnoremap <silent> <Space>q <C-q>
nnoremap <silent> <Space>c :call g:DoMarkClear()<CR>
nnoremap <silent> <Space>k 3<C-y>
nnoremap <silent> <Space>j 3<C-e>
nnoremap <silent> <Space>/ :call Prompt_Window_Create("tag")<CR>
nnoremap <silent> <Space>3 <C-w>v
nnoremap <silent> <Space>2 <C-w>c
nnoremap <silent> <Space>t :cs f t
nnoremap <silent> <Space>\ :cs find s <C-R>=expand("<cword>")<CR><CR>:call OpenQuickFixWin(&window/2)<CR>
nnoremap <silent> <Space>[ :cs find c <C-R>=expand("<cword>")<CR><CR>:call OpenQuickFixWin(&window/2)<CR>
nnoremap <silent> <Space>f :LjyatSearchFileCmd<CR>
nnoremap <silent> <Space>] :call LjyatShowTags(LjyatGetJumpTag(), 0)<CR>
nnoremap <silent> <Space>. :call LjyatShowTags(LjyatGetJumpTag(), 1)<CR>
nmap <Space><RightMouse> :call g:DoMarkClear()<CR>
nmap <Space><LeftMouse> <LeftMouse><leader>m
nnoremap <silent> <Space>l :call LjyatSearchClassParent()<CR>

vnoremap <Space>R <ESC>:call LjyatVSearchStrCurBuf()<CR>
vnoremap <Space>r <ESC>:call LjyatVSearchStrInFiles()<CR>
vnoremap <M-=> :<C-U> call AlignPattern()<CR>

"============= show preview tag config ===========
hi PreviewTagGroup ctermbg=30 ctermfg=11 guifg=Black guibg=Yellow gui=NONE
hi PromptGroup guibg=#8b2500 guifg=NONE

function! s:EchoMoreMsg(msg)
    redraw
    echohl MoreMsg
    echo "   " . a:msg
    echohl None
endfunction

function! ClosePreAndQuickWin()
    pc
    lclose
    cclose
    call LjyatGotoNormalWin()
endfunction

function! s:EchoWarningMsg(msg)
    redraw
    echohl WarningMsg
    echo "   " . a:msg
    echohl None
endfunction

function! StatusLine()
    let m = ''

    if &modified
        let m = '  %m'
    endif

    return "%-f". m ." %w  %{&fenc!=''?&fenc:&enc}  %p%% L%l/%L  %{TagDirs()}%<"
endfunction

function! Trace(prefix)
    put =a:prefix . \"# [\" . expand('%:t') . ': ' . (line('.') + 1) . ']\"' .\");\"
endfunction

function! s:SetMsgLater(msg)
    if a:msg == ''
        return
    endif
    let s:later_msg = a:msg
    call timer_start(300, "ShowMsgLater")
endfunction

function! ShowMsgLater(timer)
    call s:EchoWarningMsg(s:later_msg)
endfunction

function! Show(num)
    echo printf("0x%x, %d, bit:%0b", a:num, a:num, a:num)
endfunction

function! LjyatCppGetClass(class_function, separator)
    let list = split(a:class_function, escape(a:separator, '.'))
    let len = len(list)
    if len < 2
        return ''
    endif
    return join(list[0:len-2], a:separator)
endf

function! LjyatCppGetClassFunc(class_function, separator)
    let list = split(a:class_function, escape(a:separator, '.'))
    let len = len(list)
    if len < 2
        return []
    endif
    return list[len-1]
endf

function! LjyatCppParseParentClassName(ClassName, separator)
    " abc<aaa,bbb> this case
    let name = a:ClassName
    if name =~ '<'
        let name = split(name, '<')[0]
    endif
    " ::abc::def this case
    if name =~ '^'.escape(a:separator, '.')
        let name = name[2:]
    endif
    return name
endf

function! LjyatCppGetClassParent(CurClass, separator)
    let ParentListStr = a:CurClass
    let taginfo = taglist("^". a:CurClass . "$")
    for tag in taginfo
        if has_key(tag, 'inherits')
            if has_key(tag, 'namespace')
                let ParentListStr = ParentListStr . ' ' . tag['namespace'] . '::' . a:CurClass
            endif
            if has_key(tag, 'class')
                let ParentListStr = ParentListStr . ' ' . tag['class']
            endif
            let pre_base = LjyatCppGetClass(tag['name'], a:separator)
            if pre_base != ''
                let pre_base = pre_base. a:separator
            endif
            let parentlist = split(tag['inherits'], ',\s*')
            for base in parentlist
                let base = LjyatCppParseParentClassName(base, a:separator)

                " Base : public Base,   //skip this condition
                if base == a:CurClass
                    continue
                endif

                let ParentListStr = ParentListStr . ' '. LjyatCppGetClassParent(pre_base . base, a:separator)
                if has_key(tag, 'namespace')
                    let ParentListStr = ParentListStr . ' '. LjyatCppGetClassParent(tag['namespace']. '::' . base, a:separator)
                endif
            endfo
        endif
    endfor
    let list_class = split(ParentListStr, '\s\+')
    let list_class = uniq(list_class)
    let ParentListStr = join(list_class, " ")
    return ParentListStr
endf

function! LjyatSearchDefine()
    let separator = '::'
    if &ft == 'c' || &ft== 'cpp'
        let separator = '::'
    endif
    if &ft == 'java'
        let separator = '.'
    endif
    let pattern = input("  Search tag: ")
    call LjyatCppGetFuncDefineEntry(pattern, separator)
endf

function! LjyatSearchClassParent()
    let separator = '::'
    if &ft == 'c' || &ft== 'cpp'
        let separator = '::'
    endif
    if &ft == 'java'
        let separator = '.'
    endif
    let find_define_list = []
    let no_define_list = []
    let parent = LjyatCppGetClassParent(expand("<cword>"), separator)
    let list_class = split(parent, '\s\+')
    let list_class = sort(list_class)
    let list_class = uniq(list_class)
    for class in list_class
        let tag_list = taglist('^' . class . '$')
        if !empty(tag_list)
            call add(find_define_list, class)
        else
            call add(no_define_list, class)
        endif
    endfor
    echohl Statement
    echo find_define_list
    echohl None
    echo no_define_list
endf
function! LjyatCppGetFuncDefineEntry(name, separator)
    let func = LjyatCppGetClassFunc(a:name, a:separator)
    let classname = LjyatCppGetClass(a:name, a:separator)
    let parent_class = classname . ' '. LjyatCppGetClassParent(classname, a:separator)
    let list_class = split(parent_class, '\s\+')
    let list_class = sort(list_class)
    let list_class = uniq(list_class)

    
    echo list_class
    let show_list = []
    for class in list_class
        call OpenQuickFixWin(10)
        let search_item = class . a:separator . func
        let tag_list = taglist(search_item . '$')
        for tag in tag_list
            call add(show_list, tag['filename']. ':' .tag['cmd'][2:])
        endfor
    endfor
    let ef = &errorformat
    set efm=%f:%s
    execute "silent! cexpr show_list"
    let &errorformat=ef
endf

function! LjyatSwitchKernelCodeMode()
    let winview = winsaveview()
    let buf_num = bufnr('%')
    let msg = ''
    if s:kernel_mode == "TRUE"
        set expandtab tabstop=4 shiftwidth=4
        bufdo set expandtab tabstop=4 shiftwidth=4
        let msg = 'Normal Code Mode'
        let s:kernel_mode = "FALSE"
    else
        set noexpandtab tabstop=8 shiftwidth=8
        bufdo set noexpandtab tabstop=8 shiftwidth=8
        let msg = 'Kernel Code Mode'
        let s:kernel_mode = "TRUE"
    endif
    if buf_num != -1
        exe "b" . buf_num
    endif
    call winrestview(winview)
    call s:SetMsgLater(msg)
endfunction

function! LjyatSwitchLanguageMode()
    if s:language_mode == "EN"
        let s:language_mode = "CH"
        if !has("gui_running")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        if has("win32")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        let &guifont='YaHei Consolas Hybrid ' . g:default_linux_font_size
        call s:EchoWarningMsg("Chinese Mode")
    else
        let s:language_mode = "EN"

        if !has("gui_running")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        if has("win32")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        let &guifont=g:FontName . ' ' . g:default_linux_font_size
        call s:EchoWarningMsg("Englist Mode")
    endif
endfunction

function! LjyatShowCscopeTags(tag)
    try
        call setqflist([])
        exe "cs f g " . a:tag
        if len(getqflist()) > 1
            call OpenQuickFixWin(&window/2)
        else
            call s:EchoWarningMsg("No find tag")
            return
        endif
    catch /^Vim\%((\a\+)\)\=:E/
        if v:exception =~ "E259"
            "call s:EchoWarningMsg("cscope not found tag: " . a:tag)
        elseif v:exception =~ "E567"
            call s:EchoWarningMsg("no cscope connection !!!")
        endif
        return -1
    endtry
endfunction

function! LjyatGetJumpTag()
    "let keyword = &iskeyword
    "set iskeyword+=:
    let tag = expand("<cword>")
    "let &iskeyword=keyword
    return tag
endfunction

function! LjyatShowTags(word, cscope_tag)
    let word = a:word
    let use_cscope = a:cscope_tag

    if word == ''
        return
    endif

    call PromptClose()
    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            try
                exe "tjump " . word
            catch /^Vim\%((\a\+)\)\=:E/
                call s:EchoWarningMsg("No find tag")
            endtry
            return
        endif
    else
        " see LjyatShowTagInPreview()
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                return
            endif
        endtry
    endif
    normal zz
endfunction

function! LjyatShowTagInPreview(word)
    let word = a:word
    let use_cscope = 0
    call s:EchoMoreMsg(word)

"    silent! let tlist = taglist(word)
"    for item in tlist
"        if item['cmd'] =~ s:ignore_match_tag
"            let use_cscope = 1
"        endif
"    endfor
"
    let pw_exist = 0
    let win_cur = winnr()
    silent! wincmd P
    if &previewwindow
        let pw_exist = 1
    else
        silent! pedit
        let win_cur = winnr()
    endif

    wincmd P
    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            exe win_cur . "wincmd w"
            if !pw_exist
                pclose
            endif
            return
        endif
    else
        " some time don't get tag, but taglist() can get, this maybe a bug
        " I have know this problem, because pattern with xxx$ in tags file
        " with dos format, vim can't got it with / or ? , so skip with cscope.
        " Haha, this maybe is ctags problem, it doesn't matter.
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                exe win_cur . "wincmd w"
                if !pw_exist
                    pclose
                endif
                return
            endif
        endtry
    endif
    silent! call matchdelete(s:PreviewTagID)
    let s:PreviewTagID = matchadd('PreviewTagGroup', '\<' . word . '\>')
    if getline('.') =~ '^#define .\+[^\\]$\|;'
        normal zz
    else
        normal zt
    endif

    exe win_cur . "wincmd w"
endfunction
"============= show preview tag config end ===========

function! CompleteCurlyBrackets()
    if (getline('.')[col('.'):] =~'^\s*$')
        put = 'x'
        put = '}'
        normal =%j
        exe "s/x//"
        startinsert!
    else
        let l:col = col('.')
        exe "s/\\%" . l:col . "c{/{}/"
        call cursor('.', l:col + 1)
        startinsert
    endif
endfunction

function! LjyatNERDTreeOpenBufDir()
    call LjyatGotoNormalWin()
    set nowinfixwidth
    if (exists("t:NERDTreeBufName"))
        if (bufwinnr(t:NERDTreeBufName) != -1)
            execute "silent! NERDTreeClose"
            return
        endif
    endif
    let l:bufname = escape(bufname("%"), ' #')
    execute "silent! NERDTree " . l:bufname
    redraw!
endfunction

"=> cscope set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=1
    set nocst
    set cscopequickfix=c-,s-,g-
    " add any database in current directory
    if filereadable("GTAGS")
        silent! cs add GTAGS
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
endif

function! CleanTmpListFile(cscope_files)
    if a:cscope_files != ''
        return delete(a:cscope_files)
    endif
endfunction

function! TagDirs()
    let dirs = join(s:cscope_tag_dir_list, ",")
    if dirs == ''
        return ''
    else
        return '['.dirs.']'
    endif
endfunction

function! InitTagDirs()
    silent exe "cs kill -1"
    call CleanTmpListFile(s:tmpcscope_files)
    let &tags=''
    let &dict=''
    let s:tmpcscope_files = ''
    let s:tmpmatchfilelist = []
    let s:cscope_tag_dir_list = []
endfunction

function! RemoveTagDirs(rmdirs)
    if a:rmdirs == ''
        call InitTagDirs()
        redraw!
        return
    endif

    let newlist = copy(s:cscope_tag_dir_list)
    for dir in split(a:rmdirs, ",")
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        let rm_tag          = dir . "/tags"
        let rm_cscope       = dir . "/GTAGS"

        if !filereadable(rm_tag) || !filereadable(rm_cscope)
            call s:EchoWarningMsg("empty dir: " . dir)
            redraw!
            return
        endif
        call filter(newlist, 'v:val != dir')
    endfor
    call InitTagDirs()
    if len(newlist) != 0
        call AddTagDirs(join(newlist, ','))
    else
        redraw!
    endif
endfunction

function! AnyOneInTagDirList(dirlist)
    let filelist = copy(s:cscope_tag_dir_list)
    for dir in a:dirlist
        if s:cscope_tag_dir_list != filter(filelist, 'v:val != dir')
            return 1
        endif
    endfor
    return 0
endfunction

function! AddTagDirs(predirs)
    if a:predirs == ''
        call s:EchoWarningMsg("need tag dir")
        return
    endif


    let arglist = []
    for dir in split(a:predirs, '\s')
        call add(arglist, substitute(expand(split(dir, "\"")[0]),'/$', '',''))
    endfor
    call uniq(sort(arglist))

    if AnyOneInTagDirList(arglist)
        let addedlist = uniq(sort(arglist + s:cscope_tag_dir_list))
        call InitTagDirs()
    else
        let addedlist = arglist
    endif

    if s:tmpcscope_files == ''
        let s:tmpcscope_files = "/tmp/cscope.files." . getpid()
    endif
    for dir in addedlist
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        if dir == '.'
            let new_tag_path     = "tags"
            let new_cscope_path  = "cscope.out"
            let new_global_path  = "GTAGS"
            let new_dict_path    = "dict"
            let new_cscope_files = "cscope.files"
        else
            let new_cscope_path  = dir . "/cscope.out"
            let new_global_path  = dir . "/GTAGS"
            let new_tag_path     = dir . "/tags"
            let new_dict_path    = dir . "/dict"
            let new_cscope_files = dir . "/cscope.files"
        endif

        if filereadable(new_global_path)
            let new_cscope_path = new_global_path

            if filereadable("/usr/bin/gtags-cscope")
                set csprg=/usr/bin/gtags-cscope
            elseif filereadable("/usr/local/bin/gtags-cscope")
                set csprg=/usr/local/bin/gtags-cscope
            endif

            let g:global_mode = 1
        elseif filereadable(new_cscope_path)
            let g:global_mode = 0
            set csprg=/usr/bin/cscope
        else
            call s:EchoWarningMsg("No needed file in: " . dir)
            return
        endif

        if filereadable(new_cscope_files)
            if dir == '.'
                silent exe "!cat " . new_cscope_files . ' >> ' . s:tmpcscope_files
            else
                silent exe "!cat " . new_cscope_files . "|sed 's:^:" . dir . "/:' >> " . s:tmpcscope_files
            endif
        endif

        if len(s:cscope_tag_dir_list) == 0
            let &tags = new_tag_path
            let &dict = new_dict_path
        else
            let &tags = &tags . "," . new_tag_path
            let &dict = &dict . "," . new_dict_path
        endif
        call add(s:cscope_tag_dir_list, dir)

        if dir == '.'
            let dir = ''
        else
            "cscope prepath always need a '/'
            if stridx(dir, "/") == -1
                let dir = substitute(dir, '^', './','')
            endif
        endif
        if g:global_mode == 0
            silent! exe "cscope add " . new_cscope_path . " " . dir
        else
            let $GTAGSROOT = getcwd() . '/'. dir
            let $GTAGSDBPATH = getcwd() . '/'. dir
            silent! exe "cscope add " . new_cscope_path
        endif
    endfor
    redraw!
endfunction

function! LjyatSearchTags()
    echohl MoreMsg
    let pattern = input("  Search tag: ")
    echohl None

    if pattern == ""
        return
    endif

    try
        execute "tj /" . pattern
    catch /^Vim\%((\a\+)\)\=:E/
        call s:EchoWarningMsg("not found tag: " . pattern)
    endtry
endfunction

function! g:DoMarkClear()
    MarkClear
    call s:EchoWarningMsg("Mark Clear")
endfunction

function! Arggrep(pattern_arg)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern_arg == ''
        call s:EchoWarningMsg("pattern is null")
        return
    endif

    execute "silent! MarkClear|silent! Mark " . a:pattern_arg

    let pattern = "'" . a:pattern_arg . "'"
    call s:EchoMoreMsg("Searching String ". pattern . " ...")
    let matchlist = LjyatBuildGrepCmd(pattern, s:tmpcscope_files, 0)
    if matchlist == []
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let old = ''
    let new = ''
    let match_files = ''
    for line in matchlist
        let new = substitute(line, ':.*', '', 'g')
        if old != new
            let match_files = match_files . " " . new
        endif
        let old = new
    endfor
    exec "args " . match_files

    let ef = &errorformat
    set efm=%f:%l:%m

    let matchlen = len(matchlist)
    let g:SearchPattern = pattern
    execute "silent! cexpr matchlist"
    call OpenQuickFixWin(&window/2)
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchFunctionCaller()
    let pattern = expand("<cword>")
    if pattern == ""
        return
    endif

    let pattern = '=\s*\<' . pattern . '\>|\<' . pattern . '\>\s*\('
    let pattern = "'" . pattern . "'"
    call s:EchoMoreMsg("Searching called " . pattern . " ...")
    let match_list = LjyatBuildGrepCmd(pattern, s:tmpcscope_files, 0)
    if match_list == []
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    let g:SearchPattern = pattern
    execute "silent! cexpr match_list"
    call OpenQuickFixWin(&window/2)
    let &errorformat=ef
    redraw
endfunction

function! LjyatBuildGrepCmd(pattern, cscope_files, ignore)
    let lines = readfile(a:cscope_files)
    let left = len(lines)
    let pos = 0
    let step = 0
    let fix_step = 100000
    let result = []
    let tmp_search_files = "/tmp/cscope.files." . getpid() . "_search"
    while left > 0
        if left > fix_step
            let step = fix_step
        else
            let step = left
        endif

        let exe_file_string = join(lines[pos:(pos+step-1)])
        call writefile(lines[pos:(pos+step-1)], tmp_search_files, "b")
        let real_cmd =  'xargs grep -a -n -H -E '. ((a:ignore == 1)? " -i ": " ") . a:pattern . ' < ' . tmp_search_files
        let result = result + systemlist(real_cmd, "\n")
        let left = left - step
        let pos = pos + step
    endwhile
    if tmp_search_files != ''
        call delete(tmp_search_files)
    endif
    return result
    "return 'while read filename;do grep -a -n -H -E '. ((a:ignore == 1)? " -i ": " ") . a:pattern . ' "$filename"; done < ' . a:cscope_files
"    let real_cmd =  'xargs grep -a -n -H -E '. ((a:ignore == 1)? " -i ": " ") . a:pattern . ' < ' . a:cscope_files
"    return systemlist(real_cmd, "\n")
endfunction

function! LjyatSearchStr(pattern, cscope_files)
    if !filereadable(a:cscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern == ""
        return
    endif

    let pattern = "'" . a:pattern . "'"

    call s:EchoMoreMsg("Searching String " . pattern . " ...")
    let matchlist = LjyatBuildGrepCmd(escape(pattern, "()"), s:tmpcscope_files, &ignorecase)
    if len(matchlist) == 0
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    "ignore comment code
    if g:search_ignore_comment
        let filterlist = matchlist
        let matchlist = []
        for item in filterlist
            if matchstr(split(item, ':')[2], '^\s*//') == ""
                call add(matchlist, item)
            endif
        endfor
    endif

    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let match_string = join(matchlist, "\n")
    let ef = &errorformat
    set efm=%f:%l:%m

    let g:SearchPattern = pattern
    execute "silent! cexpr match_string"
    call OpenQuickFixWin(&window/2)
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchStrCmd()
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    echohl MoreMsg
    let pattern = input("  Search str: ", escape(expand("<cword>"), '#'))
    echohl None
    call LjyatSearchStr(pattern, s:tmpcscope_files)
endfunction

function! Argfind(pattern)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern == ''
        echo "   pattern is null"
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ") . pattern . ' ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching file " . pattern . " ...")
    let match_files = system(real_cmd, " ")
    if match_files == ""
        call s:EchoWarningMsg("No match file: " . pattern)
        return
    endif

    let args_file = ""
    for line in split(match_files, '\n')
        let args_file = args_file . " " . line
    endfor
    exec "args " . args_file
    let ef = &errorformat
    set efm=%f

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)

    let g:SearchPattern = pattern
    execute "silent! cexpr matchlist"
    call OpenQuickFixWin(&window/2)
    let &errorformat=ef
    redraw!
endfunction

function! LjyatSearchStrInFileList(pattern, filelist)
    if empty(a:filelist)
        call s:EchoWarningMsg("tmpmatchfilelist is empty")
        return
    endif

    let tmplistfile = "/tmp/cscope.matchlist." . getpid()
    call writefile(a:filelist, tmplistfile)
    call LjyatSearchStr(a:pattern, tmplistfile)
    call delete(tmplistfile)
endfunction

function! LjyatSearchStrInFileListCmd()
    if empty(s:tmpmatchfilelist)
        call s:EchoWarningMsg("matchfilelist is empty")
        return
    endif
    echohl MoreMsg
    let pattern = input("  Search str in match file: ", escape(expand("<cword>"), '#'))
    echohl None
    call LjyatSearchStrInFileList(pattern, s:tmpmatchfilelist)
endfunction

function! LjyatSearchFile(pattern, cscope_files)
    if !filereadable(a:cscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return []
    endif

    if a:pattern == ""
        return []
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep -a -i -h -E ' . ((&ignorecase == 1)? " -i ": " ")  . pattern . ' ' . a:cscope_files
    call s:EchoMoreMsg("Searching file " . pattern . " ...")

    let match_files = system(real_cmd)
    if match_files == ""
        call s:EchoWarningMsg("No match files: " . pattern)
        return []
    endif

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return []
    endif

    let ef = &errorformat
    set efm=%f

    let g:SearchPattern = pattern
    execute "silent! cexpr match_files"
    call OpenQuickFixWin(&window/2)
    let &errorformat = ef
    redraw!
    return matchlist
endfunction

function! LjyatGotoNormalWin()
    let win_count = winnr('$') "loop back to this window again
    let win_pos = 0
    while &buftype != ""
        if win_pos == win_count
            return -1
        endif
        let win_pos = win_pos + 1
        wincmd w
    endwhile
    return 0
endfunction

function! LjyatGotoWin(name)
    let winnum = bufwinnr(a:name)
    if winnum != -1
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return 0
    else
        return -1
    endif
endfunction

"<C-s> not work in terminal. so should use <F4>
function! LjyatSearchStrCurBuf()
    call LjyatGotoWin(s:PromptGetWorkBuf())
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    echohl MoreMsg
    let pattern = input("  Search cur-str: ", expand("<cword>"))
    echohl None

    if pattern == ""
        return
    endif

    let g:SearchPattern = pattern
    let pattern = "/" . pattern . "/"
    let real_cmd = "vimgrep " . pattern . " %"
    call s:EchoMoreMsg("Searching cur-str " . pattern . " ...")

    execute "silent! " . real_cmd
    call OpenQuickFixWin(&window/2)
    redraw!
endfunction

function! LjyatVSearchStrCurBuf()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    let old = @"
    exe "normal! gvy"
    let pattern = @"
    let @" = old

    let pattern = input("  Search cur-str: ", pattern)

    let g:SearchPattern = pattern
    let pattern = "/" . pattern . "/"
    let real_cmd = "vimgrep " . pattern . " %"

    execute "silent! " . real_cmd
    call OpenQuickFixWin(&window/2)
    redraw!
endfunction

func! FilterProcess(idx, val)
    let name = bufname(a:val['bufnr'])
    return name =~ g:QFlistPattern
endfunc

function! LjyatQFListFilterFile(qflist, f_pattern)
    let g:QFlistPattern = a:f_pattern
    let outlist = filter(copy(a:qflist), function('FilterProcess')) 
    call setqflist(outlist)
    call OpenQuickFixWin(&window/2)
endfunction

function! LjyatVSearchStrInFiles()
    let old = @"
    exe "normal! gvy"
    let pattern = @"
    call LjyatSearchStr(pattern, s:tmpcscope_files)
    let @" = old
    redraw!
endfunction

function! SwitchTlistTagbar()
    let tagbarwinnr = bufwinnr("__Tagbar__")
    let tlistwinnr = bufwinnr(g:TagList_title)

    if tagbarwinnr != -1
        TagbarToggle
        if tlistwinnr == -1
            Tlist
        endif
    elseif tlistwinnr != -1
        Tlist
        if tagbarwinnr == -1
            TagbarToggle
        endif
    else
        Tlist
    endif
endfunction

function! IncreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size += 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size += 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! DecreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size -= 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size -= 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! CreateTable(linenum, col)
    let c=a:col
    let l = a:linenum
    let empty_str = " "
    while c > 0
        let empty_str = empty_str . " "
        let c = c - 1
    endwhile

    while l > 0
        put =empty_str
        let l = l - 1
    endwhile
endfunction

let s:mark_index = 0
let s:mark_list=[]
function! LjyatAddBookMark()
    let s:mark_tag_{s:mark_index} = bufname('%'). ":". line('.') .":".getline('.')
    let s:mark_list+=[s:mark_tag_{s:mark_index}]
    let s:mark_index+=1
endfunction

function! LjyatShowBookMarks()
    if s:mark_index == 0
        call s:EchoWarningMsg("No marks ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m
    exe "cgetexpr s:mark_list"
    call OpenQuickFixWin(&window/2)
    let &errorformat = ef
endfunction

function! LjyatUpdateGTAGS(file)
    if len(s:cscope_tag_dir_list) == 0 || g:global_mode == 0
        return
    endif
    let curdir = getcwd()
    let dir = fnamemodify(a:file, ":p:h")
    let name = fnamemodify(a:file, ":t")
    exe 'silent !cd ' . dir . ' && global --single-update  ' . name
endfunction

function! LjyatBookMarkClear()
    let s:mark_index = 0
    let s:mark_list=[]
    execute "cclose"
endfunction

function! LoopNormalBG()
    let g:normal_guibg_idx = g:normal_guibg_idx % len(g:normal_guibg)
    exec "hi Normal guibg=" . g:normal_guibg[g:normal_guibg_idx]
    let g:normal_guibg_idx += 1
endfunction

function! LjyatFoldToggle()
    if &foldcolumn == 0
        let &foldcolumn = 4
        let &foldmethod = 'syntax'
        let &foldlevel = 2
        set foldenable
    else
        let &foldcolumn = 0
        let &foldmethod = 'manual'
        let &foldlevel = 99
        set nofoldenable
    endif
endfunction

function! AlignPattern()
    let input = input("  Align: ", '=')
    let str = escape(input, '.')
    let line_s = line("'<")
    let line_e = line("'>")
    let max = 0
    let arr = {}
    let l = line_s
    while l <= line_e
        let line = getline(l)
        if matchstr(line, str) == ''
            let l += 1
            continue
        endif
        let arr[l] = matchlist(getline(l), '\(^.*\)' . str . '\(.*\)')
        let len = strlen(arr[l][1])
        let max = (len > max ? len : max)
        let l += 1
    endwhile

    let strSpace = CreateSpaces(max)
    for [key, value] in items(arr)
        call setline(key, value[1].strpart(strSpace, 0, max-strlen(value[1])) . input . value[2])
    endfor
endfunction

function! CreateSpaces(n)
    let s = ''
    if a:n < 0
        return s
    endif
    for i in range(a:n)
        let s .= ' '
    endfor
    return s
endfunction

let g:Prompt_Title = "__File_List__"
let s:str_in = ''
let s:type = ''
let s:prompt_prefix_min = 3
let s:prompt_tagwidth = 15
let s:prompt_taglist = []
let s:prompt_keyloop = 0
let s:prompt_workbuf = ''
let s:prompt_search_file_init = 0
let s:prompt_wait_first_char = 1
let s:prompt_match_len = 0
let s:prompt_timer = 0
let s:prompt_keywait = 500
let s:prompt_register_mark = 0

function! PromptSearchTrigger(str_in, type)
    if PromptGetPrefixMin(a:str_in, a:type)
        call s:TimerStop(s:prompt_timer)
        let s:prompt_timer = timer_start(s:prompt_keywait, "s:PromptTimerHandler")
    endif
endfunction

function! PromptGetPrefixMin(str_in, type)
    if a:type == "file"
        if a:str_in =~ "^f: "
            return (len(a:str_in) >= s:prompt_prefix_min + 3)?1:0
        else
            return (len(a:str_in) >= s:prompt_prefix_min)?1:0
        endif
    else
        return (len(a:str_in) >= s:prompt_prefix_min)?1:0
    endif
endfunction

function! PromptClose()
    call s:Prompt_InputClear()
    if LjyatGotoWin(g:Prompt_Title) == 0
        close
    endif
    let s:prompt_keyloop = 0
    let s:prompt_match_len = 0
    let s:prompt_register_mark = 0
    let s:prompt_search_file_init = 0
    let s:prompt_wait_first_char = 0
    silent! call matchdelete(s:PromptGroupID)
    call LjyatGotoWin(s:PromptGetWorkBuf())
    silent! call matchdelete(s:PromptNormalGroupID)
    set nocursorline
    redraw!
endfunction

function! PromptJumpCurStr(line)
    call LjyatGotoWin(s:PromptGetWorkBuf())
    let lnu = matchstr(a:line,':\zs\d\+\ze:')
    exe lnu
    call LjyatGotoWin(g:Prompt_Title)
endfunction

function! PromptJumpTag(line)
    call LjyatGotoWin(s:PromptGetWorkBuf())
    call LjyatShowTags(a:line, 1)
endfunction

function! PromptJumpFile(file)
    if a:file == ""
        return
    endif

    call LjyatGotoWin(s:PromptGetWorkBuf())
    if bufname('%') == g:Prompt_Title
        exe "wincmd p"
    endif
    if buflisted(a:file)
        try
            exe "b ". a:file
            return
        catch /^Vim\%((\a\+)\)\=:E/
        endtry
    endif
    exe "edit " . a:file
endfunction

function! s:PromptDelLastChar(str_in, type)
    if a:type == "file" && a:str_in == "f: "
        return ""
    endif

    return a:str_in[:-2]
endfunction

function! s:CtrlKeyHandler(key, type)
    if a:key == "\<Bs>" || a:key == "\<C-Bs>" || a:key == "\<M-Bs>" || a:key == "\<S-Bs>"
        if len(s:Prompt_getInput()) > 0
            call s:Prompt_InputInit(s:PromptDelLastChar(s:Prompt_getInput(), a:type))
            call PromptSearchTrigger(s:Prompt_getInput(), a:type)
        endif
    elseif a:key == 18 "Ctrl-R register
        let s:prompt_register_mark = 1
    elseif a:key == "\<MiddleMouse>"
        call s:PromptClearSearchFileInit()
        call s:Prompt_InputAppend(getreg('*'))
        call s:PromptUpdateMsg(a:type)
    elseif a:key == "\<MiddleRelease>"
        call PromptSearchTrigger(s:Prompt_getInput(), a:type)
"    elseif a:key == 23 "Ctrl-R CTRL_W current word
"        let s:prompt_register_mark = 0
"        if LjyatGotoNormalWin() != 0
"            return
"        endif
"
"        let s:str_in = s:str_in . expand('<cword>')
"        call LjyatGotoWin(g:Prompt_Title)
"        call PromptSearchTrigger(s:str_in, a:type)
    elseif a:key == 27 "<Esc>
        call PromptClose()
        return
    elseif a:key == 0x0d "CR
        if a:type == "file"
            call PromptJumpFile(getline('.'))
        elseif a:type == "tag"
            call PromptJumpTag(getline('.'))
        elseif a:type == "cur-str"
            call PromptJumpCurStr(getline('.'))
        endif
        call PromptClose()
        return
    elseif a:key == 0x17 "CTRL_W
        call s:Prompt_InputClear()
        call s:PromptUpdateMsg(a:type)
    elseif a:key == "\<Down>" || a:key == 14 || a:key == 238
        normal j
    elseif a:key == "\<Up>" || a:key == 16 || a:key == 240
        normal k
    elseif a:key == "\<PageDown>" || a:key == 6 || a:key == 4
        normal 10j
    elseif a:key == "\<PageUp>" || a:key == 2 || a:key == 21
        normal 10k
    endif
    if a:type == "cur-str"
        call PromptJumpCurStr(getline('.'))
    endif
    call s:PromptUpdateMsg(a:type)
endfunction

function! s:PatternNumInFile(tag, file, ignorecase)
    if !filereadable(a:file)
        return 0
    endif
    let igcase = ""
    if a:ignorecase
        let igcase = " -i "
    endif
    return system('grep -a -h -E '. igcase . a:tag . ' ' . a:file . " |wc -l")
endfunction

function! s:PatternNumInDictDirs(tag, dirs)
    let tag_num = 0
    for dir in a:dirs
        let tag_num = tag_num + s:PatternNumInFile(a:tag, dir.'/dict', &ignorecase)
    endfor
    return tag_num
endfunction

function! s:Prompt_InputInit(str)
    let s:str_in = a:str
endfunction

function! s:Prompt_InputClear()
    let s:str_in = ''
endfunction

function! s:Prompt_InputAppend(str)

	if s:prompt_wait_first_char
        call s:Prompt_InputClear()
	endif
    let s:str_in = s:str_in . substitute(a:str, '[^0-9A-Za-z-_.:><+= \\]\+.*','','g')
endfunction

function! s:Prompt_getInput()
    return s:str_in
endfunction

function! s:Prompt_SearchCurStr(pat)
    sil! exe '%d _'
    let cur_file = s:PromptGetCurrentFileName(0)
    if cur_file == ''
        return
    endif
    let pattern = "'" . a:pat. "'"
    "let pattern = a:pat
    let real_cmd = 'grep -a -n -H -E ' . ((&ignorecase == 1)? " -i ": " ") .  pattern . ' ' . cur_file
    let match_files = system(real_cmd)
    let matchlist = split(match_files, '\n')
    let s:prompt_match_len = len(matchlist)
    silent! call matchdelete(s:PromptGroupID)
    let s:PromptGroupID = matchadd('PromptGroup', pattern . '\c')
    normal! gg
    put =matchlist
    normal! ggdd

    call LjyatGotoWin(s:PromptGetWorkBuf())
    silent! call matchdelete(s:PromptNormalGroupID)
    let s:PromptNormalGroupID = matchadd('PromptGroup', pattern . '\c')
    set cursorline
    call LjyatGotoWin(g:Prompt_Title)
endfunction

function! s:Prompt_SearchTag(tag)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return 1
    endif

    sil! exe '%d _'

    let s:prompt_match_len = s:PatternNumInDictDirs(a:tag, s:cscope_tag_dir_list)
    if s:prompt_match_len > g:SearchLimit
        return 1
    endif

    let pattern = "'" . a:tag . "'"
    "let real_cmd = 'global -c ' . pattern
    let real_cmd = 'grep -a -h -E ' . ((&ignorecase == 1)? " -i ": " ") . pattern . ' ' . substitute(&dict, ',', ' ', 'g')
    let match_files = system(real_cmd)
    if match_files == ""
        "call s:EchoWarningMsg("No match tag: " . pattern)
        return 0
    endif

    let s:prompt_taglist = split(match_files, '\n')
    let matchlen = len(s:prompt_taglist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return 1
    endif

    normal! gg
    let s:prompt_match_len = matchlen
    let idx = 0
    for tagitem in s:prompt_taglist
        if idx == 0
            put =tagitem
            normal! ggdd
        else
            put =tagitem
        endif
        let idx += 1
    endfor
    normal! gg

    silent! call matchdelete(s:PromptGroupID)
    let s:PromptGroupID = matchadd('PromptGroup', a:tag. '\c')
    return 1
endfunction

function! s:Prompt_SearchFile(pattern, cscope_files)
    sil! exe '%d _'
    let pattern = a:pattern
    let real_cmd = ''
    if a:pattern =~ "^f: "
        let pattern = a:pattern[3:]
        let pattern = "'" . pattern . "'"
        let real_cmd = 'grep -a -i -h -E ' . pattern . ' ' . a:cscope_files
    else
        let pattern = "'" . pattern . "'"
        let real_cmd = 'grep -a -i -h -E ' . pattern . ' ' . a:cscope_files
    endif

    let match_files = system(real_cmd)
    let matchlist = split(match_files, '\n')
    let s:prompt_match_len = len(matchlist)
    silent! call matchdelete(s:PromptGroupID)
    let s:PromptGroupID = matchadd('PromptGroup', a:pattern . '\c')
    normal! gg
    put =matchlist
    normal! ggdd
endfunction

function! s:PromptUpdateMsg(type)
    echon ""
    if s:prompt_match_len > g:SearchLimit
        redr | echoh MoreMsg | echon a:type .'   [>' . g:SearchLimit.'] >>> ' . s:Prompt_getInput() | echoh None
    else
        if s:prompt_match_len >= &window/2
            exe "resize " . &window/2
        else
            if s:prompt_match_len == 0
                resize 1
            else
                exe "resize " . s:prompt_match_len
            endif
        endif

        if a:type == "file"
            if s:prompt_search_file_init
                redr | echoh MoreMsg | echon 'Find '. s:prompt_match_len .' file: ' | echoh None
            else
                redr | echoh MoreMsg | echon 'Find '. s:prompt_match_len .' file: ' . s:Prompt_getInput() | echoh None
            endif
        else
            redr | echoh MoreMsg | echon 'Find ' . s:prompt_match_len.' ' . a:type . ': ' . s:Prompt_getInput() | echoh None
        endif
    endif
endfunction

function! s:PromptTimerHandler(timer)
    if s:type == "file"
        call s:Prompt_SearchFile(s:Prompt_getInput(), s:tmpcscope_files)
    elseif s:type == "tag"
        if s:Prompt_SearchTag(s:Prompt_getInput()) == 0
            if s:PromptGetBackupTag() != ''
                call s:Prompt_InputInit(s:PromptGetBackupTag())
                call s:Prompt_SearchTag(s:Prompt_getInput())
            else
                call s:EchoWarningMsg("No match tag")
            endif
        endif
    elseif s:type == "cur-str"
        call s:Prompt_SearchCurStr(s:Prompt_getInput())
    else
        call EchoWarningMsg("no support type search")
        call PromptClose()
        return
    endif
    call s:PromptUpdateMsg(s:type)
endfunction

function! s:TimerStop(timerid)
    if v:version >= 800
        call timer_stopall()
    else
        call timer_stop(a:timerid)
    endif
endfunction

"nameonly flag mean include path
function! s:PromptGetCurrentFileName(nameonly)
    if LjyatGotoWin(s:PromptGetWorkBuf()) == -1
        call LjyatGotoWin(g:Prompt_Title)
        return ''
    endif
    let filename = getreg("%")
    if filename != ''
        if a:nameonly
            let filename = system("basename ". filename)
            if filename != ''
                let filename = split(filename, '\.')[0]
            endif
        endif
    endif
    call LjyatGotoWin(g:Prompt_Title)
    return filename
endfunction

let s:backuptag = ''
func! s:PromptClearBackupTag()
    let s:backuptag = ''
endf

func! s:PromptSaveBackupTag(word)
    let s:backuptag = '\<' . a:word . '\>'
endf

func! s:PromptGetBackupTag()
    return s:backuptag
endf

func! s:PromptGetCurrentTagWord()
    call s:PromptClearBackupTag()
    let word = ''
    if LjyatGotoWin(s:PromptGetWorkBuf()) == -1
        call LjyatGotoWin(g:Prompt_Title)
        return word
    endif

    if &ft == 'cpp'
        call s:PromptSaveBackupTag(expand("<cword>"))
        setlocal iskeyword+=:
        let word = expand("<cword>")
        setlocal iskeyword-=:
    else
        let word = expand("<cword>")
    endif
    call LjyatGotoWin(g:Prompt_Title)
    return word
endfunction

function! s:PromptClearSearchFileInit()
    if s:prompt_search_file_init == 1
        let s:prompt_search_file_init = 0
        call s:Prompt_InputClear()
    endif
endfunction

function! s:PromptGetWorkBuf()
    return s:prompt_workbuf
endfunction

function! s:PromptSetWorkBuf()
    let s:prompt_workbuf = ''
    if &buftype == ''
        let s:prompt_workbuf = bufname('%')
    else
        call LjyatGotoNormalWin()
        if &buftype != ''
            return
        else
            let s:prompt_workbuf = bufname('%')
        endif
    endif
endfunction

function! s:Prompt_Window_Init(type)
    setlocal noreadonly
    silent! setlocal nowrap
    silent! setlocal nobuflisted
    silent! setlocal number
    silent! setlocal ma cul
    silent! setlocal buftype=nofile
    mapclear <buffer>

    let s:type = a:type
    let s:prompt_keyloop = 1
    sil! exe '%d _'
    call s:Prompt_InputClear()
    if a:type == "file"
        let cur_file = s:PromptGetCurrentFileName(1)
        if cur_file != ""
            let s:prompt_search_file_init = 1
            call s:Prompt_InputAppend(s:PromptGetCurrentFileName(1))
        endif
    elseif a:type == "tag"
        let curword = s:PromptGetCurrentTagWord()
        if curword != ''
            call s:Prompt_InputAppend('\<' . curword . '\>')
        endif
    endif

    if len(s:Prompt_getInput()) >= s:prompt_prefix_min
        call s:PromptUpdateMsg(a:type)
        call PromptSearchTrigger(s:Prompt_getInput(), a:type)
    else
        call s:Prompt_InputClear()
    endif

    call s:PromptUpdateMsg(a:type)
    let s:prompt_wait_first_char = 1
    while s:prompt_keyloop
        let nr = getchar()
        call s:PromptClearBackupTag()
        call s:TimerStop(s:prompt_timer)
        if (nr >= 0x20) &&  nr <= 0x7f "normal char
            call s:PromptClearSearchFileInit()
            let c = nr2char(nr)
            if s:prompt_register_mark
                call s:Prompt_InputAppend(getreg(c))
            else
                call s:Prompt_InputAppend(c)
            endif
            call s:PromptUpdateMsg(a:type)
            call PromptSearchTrigger(s:Prompt_getInput(), a:type)
        else
            call s:CtrlKeyHandler(nr, a:type)
        en
		let s:prompt_wait_first_char = 0
    endwhile
endfunction

function! Prompt_Window_Create(type)
    if a:type != "cur-str"
        if !filereadable(s:tmpcscope_files)
            call s:EchoWarningMsg("cscope.files not exist")
            return
        endif
    endif

    if LjyatGotoWin(g:Prompt_Title) == 0
        return
    endif

    execute "cclose"
    call s:PromptSetWorkBuf()

    exe 'silent! keepalt botright 1 split +buffer ' . g:Prompt_Title
    call s:Prompt_Window_Init(a:type)
endfunction

command! -nargs=1 Argfind call Argfind(<f-args>)
command! -nargs=+ -complete=dir A call AddTagDirs('<f-args>')
command! -nargs=* -complete=dir R call RemoveTagDirs('<f-args>')
command! LjyatNERDTreeOpenBufDir call LjyatNERDTreeOpenBufDir()
command! -nargs=1 Arggrep call Arggrep(<f-args>)
command! LjyatSearchStrCmd call LjyatSearchStrCmd()
command! LjyatSearchFunctionCaller call LjyatSearchFunctionCaller()
command! LjyatSearchFileCmd call Prompt_Window_Create("file")
command! LjyatSearchStrInFileListCmd call LjyatSearchStrInFileListCmd()
command! LjyatVSearchStrCurBuf call LjyatVSearchStrCurBuf()
command! LjyatSearchStrCurBuf call LjyatSearchStrCurBuf()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatShowBookMarks call LjyatShowBookMarks()
command! LjyatBookMarkClear call LjyatBookMarkClear()
command! LjyatSearchDefine call LjyatSearchDefine()
command! -nargs=+ CreateTable call CreateTable(<f-args>)

" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup LjyatAutoCmds
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
    autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType htm set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType css set omnifunc=csscomplete#CompleteCSS
    autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
    autocmd FileType php set omnifunc=phpcomplete#CompletePHP
    autocmd FileType c,cpp,java,cs set omnifunc=ccomplete#Complete
    autocmd FileType make setlocal iskeyword+=-
    autocmd FileType qf setlocal nu
    autocmd VimEnter * call AddTagDirs('.')

    autocmd VimLeave * call CleanTmpListFile(s:tmpcscope_files)
    autocmd BufWritePost * call LjyatUpdateGTAGS(bufname("%"))
    autocmd BufNewFile,BufRead *.aidl setf java
    autocmd BufNewFile,BufRead *.kt setf java
    autocmd BufNewFile,BufRead *.hal setf c
    autocmd BufEnter *.cu set ft=cpp
    autocmd BufEnter *.s set ft=fasm
    autocmd BufEnter *.S set ft=fasm
augroup end
" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if filereadable('projs.vim')
    source projs.vim
endif
