set nocompatible

if has("syntax")
    syntax on
endif

filetype plugin indent on

if has("gui_running")
    set guioptions-=m
    set guioptions-=T
    set guioptions-=L
    set mouse=a        "Enable mouse in gui

    if has("win32")
        set guifont=Courier_New:h13:cANSI:qDRAFT linespace=0
        set fileencodings=
        nnoremap <F7> :AcpDisable<CR>
        nnoremap <F8> :AcpEnable<CR>
    elseif has("mac")
        set guifont=Consolas:h13
    else
        "set for edit chinese
        nnoremap <F7> :set guifont=YaHei\ Consolas\ Hybrid\ 13 linespace=0<CR>:AcpDisable<CR>
        nnoremap <F8> :set guifont=Consolas\ 13 linespace=3<CR>:AcpEnable<CR>
        set guifont=Consolas\ 13 linespace=3
        set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
        colorscheme ljyat
    endif
else
    set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
    colorscheme mycterm
    set mouse=""    " Disenable mouse in vim
    nnoremap <F7> :AcpDisable<CR>
    nnoremap <F8> :AcpEnable<CR>
endif

""""""""Special in Gvim"""""""""""""""""""""""
"t_vb when use gvim , you have to set in /etc/vim/gvimrc,
"vimrc is not usefull for gvim
"set vb t_vb=
""""""""""""""""""""""""""""""""""""""""""""""
set t_Co=256
set showmatch        " Show matching brackets.
set incsearch        " Incremental search
set autowrite        " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned
set history=700
set scrolloff=0
set autoread
set ffs=unix,dos,mac
set noswapfile
set updatetime=200
set previewheight=13
set autoindent
set smartindent
set nocindent
set expandtab tabstop=4 shiftwidth=4
set number
set nohlsearch
set smarttab
set linebreak
set nobackup
set backspace=indent,eol,start
set nowrapscan
set winaltkeys=no
set diffopt=filler,vertical
set foldmethod=manual

"set statusline
set laststatus=2
set statusline=
set statusline+=%-f\ %w\ 
set statusline+=%{&fenc!=''?&fenc:&enc}\ \ 
set statusline+=%l/%L\ 
set statusline+=%-3m 

if exists('&breakindent')
    set breakindent
endif

let c_syntax_for_h = 1
let Tlist_WinWidth = 40
let Tlist_Auto_Open = 0
let g:tagbar_left = 1
let g:tagbar_sort = 0
let g:tagbar_indent = 4
let html_wrong_comments = 1
"config for taglist
let Tlist_Inc_Winwidth = 0
let NERDTreeWinPos = "right"
let s:searchhistory = 30
let s:StrPattern = ''
let s:SearchList = []

if !exists("g:tmpcscope_files")
    let g:tmpcscope_files = 'cscope.files'
endif

if &dict == ''
    let &dict = 'dict'
endif
"=> key maps
"gui_running and only vim
nnoremap <F2> :call SwitchTlistTagbar()<CR>
nnoremap <F3> :LjyatNERDTreeOpenBufDir<CR>
nnoremap j gj
nnoremap k gk
"set for view kernel code
nnoremap <F5> :set noexpandtab tabstop=8 shiftwidth=8<CR>
nnoremap <F6> :set expandtab tabstop=4 shiftwidth=4<CR>
nnoremap <F9> :call LjyatFoldToggle()<CR>
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
nnoremap <M-=> :call IncreaseFontSize()<CR>
nnoremap <M--> :call DecreaseFontSize()<CR>
nnoremap <F4> :LjyatSearchStringCurrentBuffer<CR>
nnoremap <C-s> :LjyatSearchStringCurrentBuffer<CR>

"color set
nmap / <leader>r
nmap n <leader>/
nmap N <leader>?
nmap M :MarkClear<CR><leader>m
nmap <leader>] :call LjyatShowPreviewTag()<CR>

nnoremap <Space> <Nop>

"gui_running
nnoremap <M-f> :LjyatSearchFileInFileList<CR>
vnoremap <M-r> <ESC>:call LjyatVSearchStringInFiles()<CR>
vnoremap <M-R> <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>

nnoremap <M-[> :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-\> :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-t> :cs f t
"=> switch windows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <M-2> <C-w>c
nnoremap <M-3> <C-w>v
nnoremap <M-/> :LjyatSearchTags<CR>
"=> switch windows end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"=> normal set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"move
nnoremap <M-j> 3<C-e>
nnoremap <M-k> 3<C-y>
nnoremap <M-c> :MarkClear<CR>
nnoremap <M-q> <C-q>
"copy and paste
vmap <C-c> "+y
vmap m <leader>m
nnoremap <C-v> "+p
nnoremap <M-e> g_
nnoremap <M-a> 0
nnoremap <silent> <M-1> :pc<CR>:lclose<CR>:cclose<CR>
nmap <M-m> <leader>m
nnoremap <M-]> g<C-]>
nmap <M-LeftMouse> <LeftMouse><leader>m
nnoremap <RightMouse> <C-o>
nmap <S-LeftMouse> <LeftMouse>:MarkClear<CR><leader>m
nmap <M-RightMouse> :MarkClear<CR>
nnoremap <M-l> :LjyatShowBookMarks<CR>
nnoremap C :LjyatBookMarkClear<CR>
nnoremap B :LjyatAddBookMark<CR>

"grep -E
nnoremap <M-s> :LjyatSearchStringInFiles<CR>
nnoremap <F10> :edit ++ff=dos<CR>

"vim nnoremap
nnoremap <Space>s :LjyatSearchStringInFiles<CR>
nnoremap <Space>] g<C-]>
nmap <Space>m <leader>m
nnoremap <silent> <Space>1 :pc<CR>:lclose<CR>:cclose<CR>
nnoremap <Space>a 0
nnoremap <Space>e g_
nnoremap <Space>q <C-q>
nnoremap <Space>c :MarkClear<CR>
nnoremap <Space>k 3<C-y>
nnoremap <Space>j 3<C-e>
nnoremap <Space>/ :LjyatSearchTags<CR>
nnoremap <Space>3 <C-w>v
nnoremap <Space>2 <C-w>c
nnoremap <Space>t :cs f t
nnoremap <Space>\ :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>[ :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>f :LjyatSearchFileInFileList<CR>
nnoremap <Space>] g<C-]>
nmap <Space><RightMouse> :MarkClear<CR>
nmap <Space><LeftMouse> <LeftMouse><leader>m
nnoremap <Space>l :LjyatShowBookMarks<CR>

vnoremap <Space>R <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>
vnoremap <Space>r <ESC>:call LjyatVSearchStringInFiles()<CR>

"============= show preview tag config ===========
hi PreviewTagGroup ctermbg=30 ctermfg=11 guifg=Black guibg=Yellow gui=NONE
let s:PreviewTagID = 0
if !exists("s:PreviewTagID")
    let s:PreviewTagID = 0
else
    silent! call matchdelete(s:PreviewTagID)
endif

function! LjyatShowPreviewTag()
    let word = '\<' . expand("<cword>") . '\>'
    exe " wincmd g}"
    let win_cur = winnr()
    let win_count = winnr('$') "loop back to this window again

    while win_count >= 1
        if &previewwindow
            silent! call matchdelete(s:PreviewTagID)
            let s:PreviewTagID = matchadd('PreviewTagGroup', word)
            break
        endif
        wincmd w
        let win_count -= 1
    endwhile

    exe win_cur . "wincmd w"
endfunction
"============= show preview tag config end ===========

function! CompleteCurlyBrackets()
    if (getline('.')[col('.'):] =~'^\s*$')
        put = 'x'
        put = '}'
        normal =%j
        exe "s/x//"
        startinsert!
    else
        let l:col = col('.')
        exe "s/\\%" . l:col . "c{/{}/"
        call cursor('.', l:col + 1)
        startinsert
    endif
endfunction

function! LjyatNERDTreeOpenBufDir()
    call LjyatSkipSpecWindow()
    if (exists("t:NERDTreeBufName"))
        if (bufwinnr(t:NERDTreeBufName) != -1)
            execute "silent! NERDTreeClose"
            return
        endif
    endif
    let l:bufname = escape(bufname("%"), ' #')
    execute "silent! NERDTree " . l:bufname
    redraw!
endfunction

"=> cscope set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=1
    set nocst
    " add any database in current directory
    if filereadable("cscope.out")
        silent! cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
endif

function! CleanTmpCscopeFiles()
    if g:tmpcscope_files == "cscope.files"
        return
    else
        execute "silent! !rm -rf " . g:tmpcscope_files
    endif
    redraw!
endfunction

function! ResetTagsAndCscope()
    silent exe "cs kill -1"
    call CleanTmpCscopeFiles()
    let &tags="./tags,./TAGS,tags,TAGS"
    let &dict="dict"
    let g:tmpcscope_files = 'cscope.files'

    if filereadable('cscope.out')
        silent! exe "cscope add cscope.out"
    endif
    echohl Todo
    echo "   ResetTagsAndCscope"
    echohl None
    return
    redraw!
endfunction

function! AddCscopeAndTags(predirs)
    if a:predirs == ''
        echohl Todo
        echo "   prepath is empty"
        echohl None
        return
    endif

    if g:tmpcscope_files == 'cscope.files'
        let g:tmpcscope_files = "/tmp/cscope.files." . getpid()
        if filereadable('cscope.files')
            silent exe "!cat cscope.files > " . g:tmpcscope_files
        endif
    endif

    for dir in split(a:predirs, ",")
        let dir = split(dir, "\"")[0]
        let dir = expand(dir)
        let dir = substitute(dir, '/$', '','')
        let new_tag_path=dir . "/tags"
        let new_dict_path=dir . "/dict"
        let new_cscope_path=dir . "/cscope.out"
        let new_cscope_files=dir . "/cscope.files"

        if filereadable(new_cscope_files)
            silent exe "!cat " . new_cscope_files . "|sed 's:^:" . dir . "/:' >> " . g:tmpcscope_files
        endif

        if filereadable(new_tag_path) && filereadable(new_cscope_path)
            let &tags = &tags . "," . new_tag_path
            let &dict = &dict . "," . new_dict_path

            "cscope prepath always need a '/'
            if stridx(dir, "/") == -1
                let dir = substitute(dir, '^', './','')
            endif
            silent! exe "cscope add " . new_cscope_path . " " . dir
        else
            echohl Todo
            echo "   No needed file in: " . dir
            echohl None
            return
        endif
    endfor
    redraw!
endfunction

function! LjyatSearchTags()
    echohl Question
    let pattern = input("  Search tag: ")
    echohl None

    if pattern == ""
        return
    endif

    execute "tj /" . pattern
    redraw!
endfunction

function! Arggrep(pattern_arg)
    if !filereadable(g:tmpcscope_files)
        echohl Todo
        echo "   cscope.files not exist"
        echohl None
        return
    endif

    if a:pattern_arg == ''
        echohl Todo
        echo "   pattern is null"
        echohl None
        return
    endif

    execute "silent! MarkClear|silent! Mark " . a:pattern_arg

    let pattern_arg = "'" . a:pattern_arg . "'"
    let real_cmd = 'cat ' . g:tmpcscope_files .' |xargs grep -n -E ' . pattern_arg
    echomsg "Searching all-str..."

    let match_string = system(real_cmd)
    if match_string == ""
        redraw
        echohl Todo
        echo "   No match string: " . pattern_arg
        echohl None
        return
    endif

    let old = ''
    let new = ''
    let match_files = ''
    for line in split(match_string, '\n')
        let new = substitute(line, ':.*', '', 'g')
        if old != new
            let match_files = match_files . " " . new
        endif
        let old = new
    endfor
    exec "args " . match_files

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchFunctionCaller()
    let pattern = expand("<cword>")
    if pattern == ""
        return
    endif

    let pattern = '=\s*\<' . pattern . '\>|\<' . pattern . '\>\s*\('
    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. g:tmpcscope_files . '|xargs grep -n -E ' . pattern
    echomsg "Searching caller-str..."
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        redraw
        echohl Todo
        echo "   No match string: " . pattern
        echohl None
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchStringInFiles(pattern_arg)
    if !filereadable(g:tmpcscope_files)
        echohl Todo
        echo "   cscope.files not exist"
        echohl None
        return
    endif

    echohl Question
    if a:pattern_arg != ''
        let pattern = input("  Search all-str: ", a:pattern_arg)
    else
        let pattern = input("  Search all-str: ", escape(expand("<cword>"), '#'))
    endif
    echohl None

    if pattern == ""
        return
    endif

    "silent execute "MarkClear|Mark " . pattern
    redraw

    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. g:tmpcscope_files . '|xargs grep -n -E ' . pattern
    echomsg "Searching all-str..."
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        redraw
        echohl Todo
        echo "   No match string: " . pattern
        echohl None
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! Argfind(pattern)
    if !filereadable(g:tmpcscope_files)
        echohl Todo
        echo "   cscope.files not exist"
        echohl None
        return
    endif

    if a:pattern == ''
        echo "   pattern is null"
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . g:tmpcscope_files
    echomsg "Searching file..."
    let match_files = system(real_cmd, " ")
    if match_files == ""
        redraw
        echohl Todo
        echo "   No match file: " . pattern
        echohl None
        return
    endif

    let args_file = ""
    for line in split(match_files, '\n')
        let args_file = args_file . " " . line
    endfor
    exec "args " . args_file
    let ef = &errorformat
    set efm=%f

    execute "lexpr match_files"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchFileInFileList()
    if !filereadable(g:tmpcscope_files)
        echohl Todo
        echo "   cscope.files not exist"
        echohl None
        return
    endif

    echohl Question
    let pattern = input("  Search file: ")
    echohl None

    if pattern == ""
        return
    endif

    let pattern = "'" . pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . g:tmpcscope_files
    echomsg "Searching file..."

    let match_files = system(real_cmd)
    if match_files == ""
        redraw
        echohl Todo
        echo "   No match files: " . pattern
        echohl None
        return
    endif

    let ef = &errorformat
    set efm=%f

    execute "silent! lexpr match_files"

    lopen
    let &errorformat = ef
    redraw!
endfunction

function! LjyatSkipSpecWindow()
    let win_count = winnr('$') "loop back to this window again
    let win_pos = 0
    while &buftype != ""
        if win_pos == win_count
            break
        endif
        let win_pos = win_pos + 1
        wincmd w
    endwhile
endfunction

function! LjyatSearchStringCurrentBuffer()
    call LjyatSkipSpecWindow()
    let curfilename = expand("%")
    if curfilename == ""
        echohl Todo
        echo "   buffer name is NULL"
        echohl None
        return
    endif

    echohl Question

    if len(s:SearchList) == 0
        let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
        endif
    else
        let outputlist = []
        call add(outputlist, '0. ' . expand("<cword>"))
        let idx = 1
        for item in s:SearchList
            let outputitem = idx . '. ' . item
            call add(outputlist, outputitem)
            let idx += 1
        endfor

        let l:sel_idx = inputlist(outputlist)
        if l:sel_idx == 0
            let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        else
            let s:StrPattern = input("  Search cur-str: ", s:SearchList[l:sel_idx - 1])
        endif
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
            let s:SearchList = uniq(copy(s:SearchList))
            if len(s:SearchList) > s:searchhistory
                call remove(s:SearchList, -1)
            endif
        endif
    endif


    echohl None

    if s:StrPattern == ""
        return
    endif

    "execute "silent! MarkClear|Mark " . s:StrPattern

    let l:pattern = "/" . s:StrPattern . "/"
    let real_cmd = "lvimgrep " . l:pattern . " %"
    echomsg "Searching cur-str..."
    execute "silent! " . real_cmd
    lopen
    redraw!
endfunction

function! LjyatVSearchStringCurrentBuffer()
    let curfilename = expand("%")
    if curfilename == ""
        echohl Todo
        echo "   buffer name is NULL"
        echohl None
        return
    endif

    let old = @"
    exe "normal! gvy"
    let pattern = @"
    let @" = old

    let pattern = input("  Search cur-str: ", pattern)

    let pattern = "/" . pattern . "/"
    let real_cmd = "lvimgrep " . pattern . " %"
    execute "silent! " . real_cmd

    lopen
    redraw!
endfunction

function! LjyatVSearchStringInFiles()
    let old = @"
    exe "normal! gvy"
    let pattern = @"
    call LjyatSearchStringInFiles(pattern)
    let @" = old
    redraw!
endfunction

function! SwitchTlistTagbar()
    let tagbarwinnr = bufwinnr("__Tagbar__")
    let tlistwinnr = bufwinnr(g:TagList_title)

    if tagbarwinnr != -1
        TagbarToggle
        if tlistwinnr == -1
            Tlist
        endif
    elseif tlistwinnr != -1
        Tlist
        if tagbarwinnr == -1
            TagbarToggle
        endif
    else
        Tlist
    endif
endfunction

function! IncreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size += 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size += 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! DecreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size -= 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size -= 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! CreateTable(linenum, col)
    let c=a:col
    let l = a:linenum
    let empty_str = " "
    while c > 0
        let empty_str = empty_str . " "
        let c = c - 1
    endwhile

    while l > 0
        put =empty_str
        let l = l - 1
    endwhile
endfunction

let s:mark_index = 0
let s:mark_list=[]
function! LjyatAddBookMark()
    let s:mark_tag_{s:mark_index} = bufname('%'). ":". line('.') .":".getline('.')
    let s:mark_list+=[s:mark_tag_{s:mark_index}]
    let s:mark_index+=1
endfunction

function! LjyatShowBookMarks()
    if s:mark_index == 0
        echohl Todo
        echo " No marks "
        echohl None
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m
    exe "cgetexpr s:mark_list"
    exe "botright copen"
    let &errorformat = ef
endfunction

function! LjyatBookMarkClear()
    let s:mark_index = 0
    let s:mark_list=[]
    execute "cclose"
endfunction

function! LjyatFoldToggle()
    if &foldcolumn == 0
        let &foldcolumn = 4
        let &foldmethod = 'syntax'
        let &foldlevel = 2
    else
        let &foldcolumn = 0
        let &foldmethod = 'manual'
        let &foldlevel = 99
    endif
endfunction

command! -nargs=1 Argfind call Argfind(<f-args>)
command! -nargs=+ -complete=dir A call AddCscopeAndTags('<f-args>')
command! -nargs=0 R call ResetTagsAndCscope()
command! LjyatNERDTreeOpenBufDir call LjyatNERDTreeOpenBufDir ()
command! LjyatSearchTags call LjyatSearchTags()
command! -nargs=1 Arggrep call Arggrep(<f-args>)
command! LjyatSearchStringInFiles call LjyatSearchStringInFiles('')
command! LjyatSearchFunctionCaller call LjyatSearchFunctionCaller()
command! LjyatSearchFileInFileList call LjyatSearchFileInFileList()
command! LjyatVSearchStringCurrentBuffer call LjyatVSearchStringCurrentBuffer()
command! LjyatSearchStringCurrentBuffer call LjyatSearchStringCurrentBuffer()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatShowBookMarks call LjyatShowBookMarks()
command! LjyatBookMarkClear call LjyatBookMarkClear()
command! -nargs=+ CreateTable call CreateTable(<f-args>)

" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup LjyatAutoCmds
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
    autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType htm set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType css set omnifunc=csscomplete#CompleteCSS
    autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
    autocmd FileType php set omnifunc=phpcomplete#CompletePHP
    autocmd FileType c,cpp,java,cs set omnifunc=ccomplete#Complete
    autocmd FileType make set iskeyword+=-

    autocmd VimLeave * call CleanTmpCscopeFiles()
    autocmd BufNewFile,BufRead *.aidl setf java
augroup end
" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

