set nocompatible

if has("syntax")
    syntax on
endif

filetype plugin indent on

if has("gui_running")
    set guioptions-=m
    set guioptions-=T
    set guioptions-=L
    set mouse=a        "Enable mouse in gui

    if has("win32")
        set guifont=Courier_New:h13:cANSI:qDRAFT linespace=0
        set fileencodings=
        nnoremap <F7> :AcpDisable<CR>
        nnoremap <F8> :AcpEnable<CR>
    elseif has("mac")
        set guifont=Consolas:h13
    else
        "set for edit chinese
        nnoremap <F7> :set guifont=YaHei\ Consolas\ Hybrid\ 13 linespace=0<CR>:AcpDisable<CR>
        nnoremap <F8> :set guifont=Consolas\ 13 linespace=3<CR>:AcpEnable<CR>
        set guifont=Consolas\ 13 linespace=3
        set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
        colorscheme ljyat
    endif
else
    set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
    colorscheme mycterm
    set mouse=""    " Disenable mouse in vim
    nnoremap <F7> :AcpDisable<CR>
    nnoremap <F8> :AcpEnable<CR>
endif

""""""""Special in Gvim"""""""""""""""""""""""
"t_vb when use gvim , you have to set in /etc/vim/gvimrc,
"vimrc is not usefull for gvim
"set vb t_vb=
""""""""""""""""""""""""""""""""""""""""""""""
set t_Co=256
set showmatch        " Show matching brackets.
set incsearch        " Incremental search
set autowrite        " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned
set history=700
set scrolloff=0
set autoread
set ffs=unix,dos,mac
set noswapfile
set updatetime=200
set previewheight=13
set autoindent
set smartindent
set nocindent
set expandtab tabstop=4 shiftwidth=4
set number
set nohlsearch
set smarttab
set linebreak
set nobackup
set backspace=indent,eol,start
set nowrapscan
set winaltkeys=no
set diffopt=filler,vertical
set foldmethod=manual
set shell=/bin/bash

"set statusline
set laststatus=2
set statusline=%!StatusLine()

if exists('&breakindent')
    set breakindent
endif

let c_syntax_for_h = 1
let Tlist_WinWidth = 40
let Tlist_Auto_Open = 0
let g:tagbar_left = 1
let g:tagbar_sort = 0
let g:tagbar_indent = 4
let html_wrong_comments = 1
"config for taglist
let Tlist_Inc_Winwidth = 0
let NERDTreeWinPos = "right"
let s:searchhistory = 30
let s:StrPattern = ''
let s:SearchList = []
let g:SearchLimit = 5000

if !exists("g:tmpcscope_files")
    let g:tmpcscope_files = 'cscope.files'
    let g:cscope_tag_dir_list = []
endif

if &dict == ''
    let &dict = 'dict'
endif
"=> key maps
"gui_running and only vim
nnoremap <F2> :call SwitchTlistTagbar()<CR>
nnoremap <F3> :LjyatNERDTreeOpenBufDir<CR>
nnoremap j gj
nnoremap k gk
"set for view kernel code
nnoremap <F5> :set noexpandtab tabstop=8 shiftwidth=8<CR>
nnoremap <F6> :set expandtab tabstop=4 shiftwidth=4<CR>
nnoremap <F9> :call LjyatFoldToggle()<CR>
nnoremap <C-F9> :let &foldlevel=&foldlevel-1<CR>
nnoremap <C-F10> :let &foldlevel=&foldlevel+1<CR>
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
nnoremap <M-=> :call IncreaseFontSize()<CR>
nnoremap <M--> :call DecreaseFontSize()<CR>
nnoremap <F4> :LjyatSearchStringCurrentBuffer<CR>
nnoremap <C-s> :LjyatSearchStringCurrentBuffer<CR>

"color set
nmap / <leader>r
nmap n <leader>/
nmap N <leader>?
nmap M :MarkClear<CR><leader>m
nmap <leader>] :call LjyatShowPreviewTags()<CR>

nnoremap <Space> <Nop>

"gui_running
nnoremap <M-f> :LjyatSearchFileInFileList<CR>
vnoremap <M-r> <ESC>:call LjyatVSearchStringInFiles()<CR>
vnoremap <M-R> <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>

nnoremap <M-[> :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-\> :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-t> :cs f t
"=> switch windows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <M-2> <C-w>c
nnoremap <M-3> <C-w>v
nnoremap <M-/> :LjyatSearchTags<CR>
"=> switch windows end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"=> normal set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"move
nnoremap <M-j> 3<C-e>
nnoremap <M-k> 3<C-y>
nnoremap <M-c> :MarkClear<CR>
nnoremap <M-q> <C-q>
"copy and paste
vmap <C-c> "+y
vmap m <leader>m
nnoremap <C-v> "+p
nnoremap <M-e> g_
nnoremap <M-a> 0
nnoremap <silent> <M-1> :pc<CR>:lclose<CR>:cclose<CR>
nmap <M-m> <leader>m
nnoremap <M-]> :call LjyatShowTags()<CR>
nmap <M-LeftMouse> <LeftMouse><leader>m
nnoremap <RightMouse> <C-o>
nmap <S-LeftMouse> <LeftMouse>:MarkClear<CR><leader>m
nmap <M-RightMouse> :MarkClear<CR>
nnoremap <M-l> :LjyatShowBookMarks<CR>
nnoremap C :LjyatBookMarkClear<CR>
nnoremap B :LjyatAddBookMark<CR>

"grep -E
nnoremap <M-s> :LjyatSearchStringInFiles<CR>
nnoremap <F10> :edit ++ff=dos<CR>

"vim nnoremap
nnoremap <Space>s :LjyatSearchStringInFiles<CR>
nmap <Space>m <leader>m
nnoremap <silent> <Space>1 :pc<CR>:lclose<CR>:cclose<CR>
nnoremap <Space>a 0
nnoremap <Space>e g_
nnoremap <Space>q <C-q>
nnoremap <Space>c :MarkClear<CR>
nnoremap <Space>k 3<C-y>
nnoremap <Space>j 3<C-e>
nnoremap <Space>/ :LjyatSearchTags<CR>
nnoremap <Space>3 <C-w>v
nnoremap <Space>2 <C-w>c
nnoremap <Space>t :cs f t
nnoremap <Space>\ :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>[ :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>f :LjyatSearchFileInFileList<CR>
nnoremap <Space>] :call LjyatShowTags()<CR>
nmap <Space><RightMouse> :MarkClear<CR>
nmap <Space><LeftMouse> <LeftMouse><leader>m
nnoremap <Space>l :LjyatShowBookMarks<CR>

vnoremap <Space>R <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>
vnoremap <Space>r <ESC>:call LjyatVSearchStringInFiles()<CR>

"============= show preview tag config ===========
hi PreviewTagGroup ctermbg=30 ctermfg=11 guifg=Black guibg=Yellow gui=NONE
if !exists("s:PreviewTagID")
    let s:PreviewTagID = 0
else
    silent! call matchdelete(s:PreviewTagID)
endif

function! s:EchoMsg(msg)
    redraw
    echohl Todo
    echo a:msg
    echohl None
    return
endfunction

function! StatusLine()
    let m = ''
    let w = ''

    if &modified
        let m = '  %m'
    endif

    if &previewwindow
        let w = '  %w'
    endif

    return "%-f". m . w ."  %{&fenc!=''?&fenc:&enc}  %l/%L  %{TagDirs()}%<"
endfunction

function! Trace(prefix)
    put =a:prefix . \"# [\" . expand('%:t') . ': ' . (line('.') + 1) . ']\"' .\");\"
endfunction

function! LjyatShowTags()
    let word = expand("<cword>")
    if empty(taglist('\<'. word . '\>'))
        try
            exe "cs f g " . word
        catch /^Vim\%((\a\+)\)\=:E259/
            call s:EchoMsg(" not found tag: " . word)
        endtry
        return
    endif
    exe "tjump " . word
endfunction

function! LjyatShowPreviewTags()
    let word = '\<' . expand("<cword>") . '\>'
    if empty(taglist(word))
        try
            exe "cs f g " . expand("<cword>")
        catch /^Vim\%((\a\+)\)\=:E259/
            call s:EchoMsg(" not found tag: " . word)
        endtry
        return
    endif

    exe " wincmd g}"
    let win_cur = winnr()
    let win_count = winnr('$') "loop back to this window again

    while win_count >= 1
        if &previewwindow
            silent! call matchdelete(s:PreviewTagID)
            let s:PreviewTagID = matchadd('PreviewTagGroup', word)
            break
        endif
        wincmd w
        let win_count -= 1
    endwhile

    exe win_cur . "wincmd w"
endfunction
"============= show preview tag config end ===========

function! CompleteCurlyBrackets()
    if (getline('.')[col('.'):] =~'^\s*$')
        put = 'x'
        put = '}'
        normal =%j
        exe "s/x//"
        startinsert!
    else
        let l:col = col('.')
        exe "s/\\%" . l:col . "c{/{}/"
        call cursor('.', l:col + 1)
        startinsert
    endif
endfunction

function! LjyatNERDTreeOpenBufDir()
    call LjyatSkipSpecWindow()
    if (exists("t:NERDTreeBufName"))
        if (bufwinnr(t:NERDTreeBufName) != -1)
            execute "silent! NERDTreeClose"
            return
        endif
    endif
    let l:bufname = escape(bufname("%"), ' #')
    execute "silent! NERDTree " . l:bufname
    redraw!
endfunction

"=> cscope set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=1
    set nocst
    " add any database in current directory
    if filereadable("cscope.out")
        silent! cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
endif

function! CleanTmpListFile()
    if g:tmpcscope_files == "cscope.files"
        return
    elseif filereadable(g:tmpcscope_files)
        execute "silent! !rm -rf " . g:tmpcscope_files
    endif
endfunction

function! TagDirs()
    let dirs = join(g:cscope_tag_dir_list, ",")
    if dirs == ''
        return ''
    else
        return '['.dirs.']'
    endif
endfunction

function! InitTagDirs()
    silent exe "cs kill -1"
    call CleanTmpListFile()
    let &tags="./tags,./TAGS,tags,TAGS"
    let &dict="dict"
    let g:tmpcscope_files = 'cscope.files'
    let g:cscope_tag_dir_list = []
    if filereadable('cscope.out')
        silent! exe "cscope add cscope.out"
    endif
endfunction

function! RemoveTagDirs(rmdirs)
    if a:rmdirs == ''
        call InitTagDirs()
        redraw!
        return
    endif

    let newlist = copy(g:cscope_tag_dir_list)
    for dir in split(a:rmdirs, ",")
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        let rm_tag          = dir . "/tags"
        let rm_cscope       = dir . "/cscope.out"

        if !filereadable(rm_tag) || !filereadable(rm_cscope)
            call s:EchoMsg("   empty dir: " . dir)
            redraw!
            return
        endif
        call filter(newlist, 'v:val != dir')
    endfor
    call InitTagDirs()
    if len(newlist) != 0
        call AddTagDirs(join(newlist, ','))
    else
        redraw!
    endif
endfunction

function! AnyOneInTagDirList(dirlist)
    let filelist = copy(g:cscope_tag_dir_list)
    for dir in a:dirlist
        if g:cscope_tag_dir_list != filter(filelist, 'v:val != dir')
            return 1
        endif
    endfor
    return 0
endfunction

function! AddTagDirs(predirs)
    if a:predirs == ''
        call s:EchoMsg("   need tag dir")
        return
    endif

    let arglist = []
    for dir in split(a:predirs, ",")
        call add(arglist, substitute(expand(split(dir, "\"")[0]),'/$', '',''))
    endfor
    call uniq(sort(arglist))

    if AnyOneInTagDirList(arglist)
        let addedlist = uniq(sort(arglist + g:cscope_tag_dir_list))
        call InitTagDirs()
    else
        let addedlist = arglist
    endif

    if g:tmpcscope_files == 'cscope.files'
        let g:tmpcscope_files = "/tmp/cscope.files." . getpid()
        if filereadable('cscope.files')
            silent exe "!cat cscope.files > " . g:tmpcscope_files
        endif
    endif

    for dir in addedlist
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        let new_tag_path = dir . "/tags"
        let new_dict_path = dir . "/dict"
        let new_cscope_path = dir . "/cscope.out"
        let new_cscope_files = dir . "/cscope.files"

        if !filereadable(new_tag_path) || !filereadable(new_cscope_path)
            call s:EchoMsg("   No needed file in: " . dir)
            return
        endif

        if filereadable(new_cscope_files)
            silent exe "!cat " . new_cscope_files . "|sed 's:^:" . dir . "/:' >> " . g:tmpcscope_files
        endif

        let &tags = &tags . "," . new_tag_path
        let &dict = &dict . "," . new_dict_path
        call add(g:cscope_tag_dir_list, dir)

        "cscope prepath always need a '/'
        if stridx(dir, "/") == -1
            let dir = substitute(dir, '^', './','')
        endif
        silent! exe "cscope add " . new_cscope_path . " " . dir
    endfor
    redraw!
endfunction

function! LjyatSearchTags()
    echohl Question
    let pattern = input("  Search tag: ")
    echohl None

    if pattern == ""
        return
    endif

    execute "tj /" . pattern
    redraw!
endfunction

function! Arggrep(pattern_arg)
    if !filereadable(g:tmpcscope_files)
        call s:EchoMsg("   cscope.files not exist")
        return
    endif

    if a:pattern_arg == ''
        call s:EchoMsg("   pattern is null")
        return
    endif

    execute "silent! MarkClear|silent! Mark " . a:pattern_arg

    let pattern_arg = "'" . a:pattern_arg . "'"
    let real_cmd = 'cat ' . g:tmpcscope_files .' |xargs grep -n -E ' . pattern_arg
    call s:EchoMsg("Searching all-str...")

    let match_string = system(real_cmd)
    if match_string == ""
        call s:EchoMsg("   No match string: " . pattern_arg)
        return
    endif

    let old = ''
    let new = ''
    let match_files = ''
    for line in split(match_string, '\n')
        let new = substitute(line, ':.*', '', 'g')
        if old != new
            let match_files = match_files . " " . new
        endif
        let old = new
    endfor
    exec "args " . match_files

    let ef = &errorformat
    set efm=%f:%l:%m

    let matchlist = split(match_string, '\n')
    let matchlen = len(matchlist)
    execute "lexpr matchlist"
    lopen
    let &errorformat=ef
    call s:EchoMsg(" ". matchlen . " matches for " . pattern_arg )
endfunction

function! LjyatSearchFunctionCaller()
    let pattern = expand("<cword>")
    if pattern == ""
        return
    endif

    let pattern = '=\s*\<' . pattern . '\>|\<' . pattern . '\>\s*\('
    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. g:tmpcscope_files . '|xargs grep -n -E ' . pattern
    call s:EchoMsg("Searching caller-str...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoMsg("   No match string: " . pattern)
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchStringInFiles(pattern_arg)
    if !filereadable(g:tmpcscope_files)
        call s:EchoMsg("   cscope.files not exist")
        return
    endif

    echohl Question
    if a:pattern_arg != ''
        let pattern = input("  Search all-str: ", a:pattern_arg)
    else
        let pattern = input("  Search all-str: ", escape(expand("<cword>"), '#'))
    endif
    echohl None

    if pattern == ""
        return
    endif

    "silent execute "MarkClear|Mark " . pattern
    redraw

    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. g:tmpcscope_files . '|xargs grep -n -E ' . pattern
    call s:EchoMsg("Searching all-str...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoMsg("   No match string: " . pattern)
        return
    endif

    let matchlist = split(match_string, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMsg("   match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    call s:EchoMsg(" ". matchlen . " matches for " . pattern )
endfunction

function! Argfind(pattern)
    if !filereadable(g:tmpcscope_files)
        call s:EchoMsg("   cscope.files not exist")
        return
    endif

    if a:pattern == ''
        echo "   pattern is null"
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . g:tmpcscope_files
    call s:EchoMsg("Searching file...")
    let match_files = system(real_cmd, " ")
    if match_files == ""
        call s:EchoMsg("   No match file: " . pattern)
        return
    endif

    let args_file = ""
    for line in split(match_files, '\n')
        let args_file = args_file . " " . line
    endfor
    exec "args " . args_file
    let ef = &errorformat
    set efm=%f

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    execute "lexpr matchlist"
    lopen
    let &errorformat=ef
    call s:EchoMsg(" ". matchlen . " matches for " . pattern)
endfunction

function! LjyatSearchFileInFileList()
    if !filereadable(g:tmpcscope_files)
        call s:EchoMsg("   cscope.files not exist")
        return
    endif

    echohl Question
    let pattern = input("  Search file: ")
    echohl None

    if pattern == ""
        return
    endif

    let pattern = "'" . pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . g:tmpcscope_files
    call s:EchoMsg("Searching file...")

    let match_files = system(real_cmd)
    if match_files == ""
        call s:EchoMsg("   No match files: " . pattern)
        return
    endif

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMsg("   match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let ef = &errorformat
    set efm=%f

    execute "silent! lexpr match_files"

    lopen
    let &errorformat = ef
    redraw!
    call s:EchoMsg(" ". matchlen . " matches for " . pattern )
endfunction

function! LjyatSkipSpecWindow()
    let win_count = winnr('$') "loop back to this window again
    let win_pos = 0
    while &buftype != ""
        if win_pos == win_count
            break
        endif
        let win_pos = win_pos + 1
        wincmd w
    endwhile
endfunction

function! LjyatSearchStringCurrentBuffer()
    call LjyatSkipSpecWindow()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoMsg("   buffer name is NULL")
        return
    endif

    echohl Question

    if len(s:SearchList) == 0
        let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
        endif
    else
        let outputlist = []
        call add(outputlist, '0. ' . expand("<cword>"))
        let idx = 1
        for item in s:SearchList
            let outputitem = idx . '. ' . item
            call add(outputlist, outputitem)
            let idx += 1
        endfor

        let l:sel_idx = inputlist(outputlist)
        if l:sel_idx == 0
            let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        else
            let s:StrPattern = input("  Search cur-str: ", s:SearchList[l:sel_idx - 1])
        endif
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
            let s:SearchList = uniq(copy(s:SearchList))
            if len(s:SearchList) > s:searchhistory
                call remove(s:SearchList, -1)
            endif
        endif
    endif


    echohl None

    if s:StrPattern == ""
        return
    endif

    "execute "silent! MarkClear|Mark " . s:StrPattern

    let l:pattern = "/" . s:StrPattern . "/"
    let real_cmd = "lvimgrep " . l:pattern . " %"
    call s:EchoMsg("Searching cur-str...")
    execute "silent! " . real_cmd
    lopen
    redraw!
endfunction

function! LjyatVSearchStringCurrentBuffer()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoMsg("   buffer name is NULL")
        return
    endif

    let old = @"
    exe "normal! gvy"
    let pattern = @"
    let @" = old

    let pattern = input("  Search cur-str: ", pattern)

    let pattern = "/" . pattern . "/"
    let real_cmd = "lvimgrep " . pattern . " %"
    execute "silent! " . real_cmd

    lopen
    redraw!
endfunction

function! LjyatVSearchStringInFiles()
    let old = @"
    exe "normal! gvy"
    let pattern = @"
    call LjyatSearchStringInFiles(pattern)
    let @" = old
    redraw!
endfunction

function! SwitchTlistTagbar()
    let tagbarwinnr = bufwinnr("__Tagbar__")
    let tlistwinnr = bufwinnr(g:TagList_title)

    if tagbarwinnr != -1
        TagbarToggle
        if tlistwinnr == -1
            Tlist
        endif
    elseif tlistwinnr != -1
        Tlist
        if tagbarwinnr == -1
            TagbarToggle
        endif
    else
        Tlist
    endif
endfunction

function! IncreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size += 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size += 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! DecreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size -= 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size -= 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! CreateTable(linenum, col)
    let c=a:col
    let l = a:linenum
    let empty_str = " "
    while c > 0
        let empty_str = empty_str . " "
        let c = c - 1
    endwhile

    while l > 0
        put =empty_str
        let l = l - 1
    endwhile
endfunction

let s:mark_index = 0
let s:mark_list=[]
function! LjyatAddBookMark()
    let s:mark_tag_{s:mark_index} = bufname('%'). ":". line('.') .":".getline('.')
    let s:mark_list+=[s:mark_tag_{s:mark_index}]
    let s:mark_index+=1
endfunction

function! LjyatShowBookMarks()
    if s:mark_index == 0
        call s:EchoMsg(" No marks ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m
    exe "cgetexpr s:mark_list"
    exe "botright copen"
    let &errorformat = ef
endfunction

function! LjyatBookMarkClear()
    let s:mark_index = 0
    let s:mark_list=[]
    execute "cclose"
endfunction

function! LjyatFoldToggle()
    if &foldcolumn == 0
        let &foldcolumn = 4
        let &foldmethod = 'syntax'
        let &foldlevel = 2
        set foldenable
    else
        let &foldcolumn = 0
        let &foldmethod = 'manual'
        let &foldlevel = 99
        set nofoldenable
    endif
endfunction

command! -nargs=1 Argfind call Argfind(<f-args>)
command! -nargs=+ -complete=dir A call AddTagDirs('<f-args>')
command! -nargs=* -complete=dir R call RemoveTagDirs('<f-args>')
command! -nargs=0  S echo TagDirs()
command! LjyatNERDTreeOpenBufDir call LjyatNERDTreeOpenBufDir ()
command! LjyatSearchTags call LjyatSearchTags()
command! -nargs=1 Arggrep call Arggrep(<f-args>)
command! LjyatSearchStringInFiles call LjyatSearchStringInFiles('')
command! LjyatSearchFunctionCaller call LjyatSearchFunctionCaller()
command! LjyatSearchFileInFileList call LjyatSearchFileInFileList()
command! LjyatVSearchStringCurrentBuffer call LjyatVSearchStringCurrentBuffer()
command! LjyatSearchStringCurrentBuffer call LjyatSearchStringCurrentBuffer()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatShowBookMarks call LjyatShowBookMarks()
command! LjyatBookMarkClear call LjyatBookMarkClear()
command! -nargs=+ CreateTable call CreateTable(<f-args>)

" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup LjyatAutoCmds
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
    autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType htm set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType css set omnifunc=csscomplete#CompleteCSS
    autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
    autocmd FileType php set omnifunc=phpcomplete#CompletePHP
    autocmd FileType c,cpp,java,cs set omnifunc=ccomplete#Complete
    autocmd FileType qf setlocal nowrap

    autocmd VimLeave * call CleanTmpListFile()
    autocmd BufNewFile,BufRead *.aidl setf java
augroup end
" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" => Set mark color
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
hi MarkWord1  ctermbg=Cyan     ctermfg=Black  guibg=#8CCBEA    guifg=Black
hi MarkWord2  ctermbg=Green    ctermfg=Black  guibg=#A4E57E    guifg=Black
hi MarkWord3  ctermbg=Yellow   ctermfg=Black  guibg=#FFDB72    guifg=Black
hi MarkWord4  ctermbg=Red      ctermfg=Black  guibg=#FF7272    guifg=Black
hi MarkWord5  ctermbg=Magenta  ctermfg=Black  guibg=#FFB3FF    guifg=Black
hi MarkWord6  ctermbg=Blue     ctermfg=Black  guibg=#9999FF    guifg=Black
