set nocompatible

if has("syntax")
    syntax on
endif

filetype plugin indent on

if has("unix")
    " this is default set for terminal,
    " change option if needed in gui
    set shell=/bin/bash
    set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
    colorscheme mycterm
    set mouse=""
endif

if has("gui_running")
    set guioptions-=m
    set guioptions-=T
    set guioptions-=L
    set mouse=a        "Enable mouse in gui

    if has("win32")
        set guifont=Courier_New:h13:cANSI:qDRAFT linespace=0
        set fileencodings=
    elseif has("mac")
        set guifont=Monaco:h13
        colorscheme ljyat
    else
        set guifont=Inconsolata\ 14
        set fileencodings=utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,ucs-bom
        colorscheme ljyat
    endif
endif

""""""""Special in Gvim"""""""""""""""""""""""
"t_vb when use gvim , you have to set in /etc/vim/gvimrc,
"vimrc is not usefull for gvim
"set vb t_vb=
""""""""""""""""""""""""""""""""""""""""""""""
set t_Co=256
set showmatch        " Show matching brackets.
set incsearch        " Incremental search
set autowrite        " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned
set history=700
set scrolloff=0
set autoread
set ffs=unix,dos,mac
set noswapfile
set updatetime=200
set previewheight=13
set autoindent
set smartindent
set nocindent
set expandtab tabstop=4 shiftwidth=4
set nohlsearch
set smarttab
set linebreak
set nobackup
set backspace=indent,eol,start
set nowrapscan
set winaltkeys=no
set diffopt=filler,vertical
set foldmethod=manual

"set statusline
set laststatus=2
set statusline=%!StatusLine()

let c_syntax_for_h = 1
let Tlist_WinWidth = 40
let Tlist_Auto_Open = 0
let g:tagbar_left = 1
let g:tagbar_sort = 0
let g:tagbar_indent = 4
let html_wrong_comments = 1
"config for taglist
let Tlist_Inc_Winwidth = 0
let NERDTreeWinPos = "right"
let s:searchhistory = 5
let s:StrPattern = ''
let s:SearchList = []
let g:SearchLimit = 5000

if exists('&breakindent')
    set breakindent
endif

if !exists("s:tmpcscope_files")
    let s:tmpcscope_files = ''
    let s:cscope_tag_dir_list = []
endif

if !exists("s:language_mode")
    let s:language_mode = "EN"
endif

if !exists("s:kernel_mode")
    let s:kernel_mode = "FALSE"
endif

if !exists("s:ignore_match_tag")
    let s:ignore_match_tag = "EXPORT_SYMBOL"
endif

if exists("s:PreviewTagID")
    silent! call matchdelete(s:PreviewTagID)
else
    let s:PreviewTagID = -1
endif

if &dict == ''
    let &dict = 'dict'
endif
"=> key maps
nnoremap j gj
nnoremap k gk
nnoremap <F2> :call SwitchTlistTagbar()<CR>
nnoremap <F3> :LjyatNERDTreeOpenBufDir<CR>
nnoremap <F5> :call LjyatSwitchKernelCodeMode()<CR>
nnoremap <F8> :call LjyatSwitchLanguageMode()<CR>
nnoremap <F9> :call LjyatFoldToggle()<CR>
nnoremap <C-F9> :let &foldlevel=&foldlevel-1<CR>
nnoremap <C-F10> :let &foldlevel=&foldlevel+1<CR>
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
nnoremap <M-=> :call IncreaseFontSize()<CR>
nnoremap <M--> :call DecreaseFontSize()<CR>
nnoremap <F4> :LjyatSearchStringCurrentBuffer<CR>
nnoremap <C-s> :LjyatSearchStringCurrentBuffer<CR>

"color set
nmap / <leader>r
nmap n <leader>/
nmap N <leader>?
nmap M :MarkClear<CR><leader>m
nmap <leader>] :call LjyatShowTagInPreview(expand("<cword>"))<CR>

nnoremap <Space> <Nop>
nnoremap <M-f> :LjyatSearchFileInFileList<CR>
vnoremap <M-r> <ESC>:call LjyatVSearchStringInFiles()<CR>
vnoremap <M-R> <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>

nnoremap <M-[> :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-\> :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <M-t> :cs f t
"=> switch windows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <M-2> <C-w>c
nnoremap <M-3> <C-w>v
nnoremap <M-/> :call LjyatSearchTags()<CR>
"=> switch windows end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"=> normal set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"move
nnoremap <M-j> 3<C-e>
nnoremap <M-k> 3<C-y>
nnoremap <M-c> :MarkClear<CR>
nnoremap <M-q> <C-q>
"copy and paste
vmap <C-c> "+y
vmap m <leader>m
nnoremap <C-v> "+p
nnoremap <M-e> g_
nnoremap <M-a> 0
nnoremap <silent> <M-1> :pc<CR>:lclose<CR>:cclose<CR>
nmap <M-m> <leader>m
nnoremap <M-]> :call LjyatShowTags(expand("<cword>"))<CR>
nmap <M-LeftMouse> <LeftMouse><leader>m
nnoremap <RightMouse> <C-o>
nmap <S-LeftMouse> <LeftMouse>:MarkClear<CR><leader>m
nmap <M-RightMouse> :MarkClear<CR>
nnoremap <M-l> :LjyatShowBookMarks<CR>
nnoremap C :LjyatBookMarkClear<CR>
nnoremap B :LjyatAddBookMark<CR>

"grep -E
nnoremap <M-s> :LjyatSearchStringInFiles<CR>
nnoremap <F10> :edit ++ff=dos<CR>

"vim nnoremap
nnoremap <Space>s :LjyatSearchStringInFiles<CR>
nmap <Space>m <leader>m
nnoremap <silent> <Space>1 :pc<CR>:lclose<CR>:cclose<CR>
nnoremap <Space>a 0
nnoremap <Space>e g_
nnoremap <Space>q <C-q>
nnoremap <Space>c :MarkClear<CR>
nnoremap <Space>k 3<C-y>
nnoremap <Space>j 3<C-e>
nnoremap <Space>/ :call LjyatSearchTags()<CR>
nnoremap <Space>3 <C-w>v
nnoremap <Space>2 <C-w>c
nnoremap <Space>t :cs f t
nnoremap <Space>\ :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>[ :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <Space>f :LjyatSearchFileInFileList<CR>
nnoremap <Space>] :call LjyatShowTags(expand("<cword>"))<CR>
nmap <Space><RightMouse> :MarkClear<CR>
nmap <Space><LeftMouse> <LeftMouse><leader>m
nnoremap <Space>l :LjyatShowBookMarks<CR>

vnoremap <Space>R <ESC>:call LjyatVSearchStringCurrentBuffer()<CR>
vnoremap <Space>r <ESC>:call LjyatVSearchStringInFiles()<CR>
vnoremap <M-=> :<C-U> call AlignPattern()<CR>

"============= show preview tag config ===========
hi PreviewTagGroup ctermbg=30 ctermfg=11 guifg=Black guibg=Yellow gui=NONE

function! s:EchoMoreMsg(msg)
    redraw
    echohl MoreMsg
    echo "   " . a:msg
    echohl None
endfunction

function! s:EchoWarningMsg(msg)
    redraw
    echohl WarningMsg
    echo "   " . a:msg
    echohl None
endfunction

function! StatusLine()
    let m = ''

    if &modified
        let m = '  %m'
    endif

    return "%-f". m ." %w  %{&fenc!=''?&fenc:&enc}  %p%% L%l/%L  %{TagDirs()}%<"
endfunction

function! Trace(prefix)
    put =a:prefix . \"# [\" . expand('%:t') . ': ' . (line('.') + 1) . ']\"' .\");\"
endfunction

function! LjyatSwitchKernelCodeMode()
    let winview = winsaveview()
    let buf_num = bufnr('%')
    if s:kernel_mode == "TRUE"
        bufdo set expandtab tabstop=4 shiftwidth=4
        let s:kernel_mode = "FALSE"
        call s:EchoWarningMsg("Normal Code Mode")
    else
        bufdo set noexpandtab tabstop=8 shiftwidth=8
        let s:kernel_mode = "TRUE"
        call s:EchoWarningMsg("Kernel Code Mode")
    endif
    if buf_num != -1
        exe "b" . buf_num
    endif
    call winrestview(winview)
endfunction

function! LjyatSwitchLanguageMode()
    if s:language_mode == "EN"
        AcpDisable
        let s:language_mode = "CH"
        if !has("gui_running")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        if has("win32")
            call s:EchoWarningMsg("Chinese Mode")
            return
        endif

        set guifont=YaHei\ Consolas\ Hybrid\ 13 linespace=0
        call s:EchoWarningMsg("Chinese Mode")
    else
        AcpEnable
        let s:language_mode = "EN"

        if !has("gui_running")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        if has("win32")
            call s:EchoWarningMsg("Englist Mode")
            return
        endif
        set guifont=Inconsolata\ 14
        call s:EchoWarningMsg("Englist Mode")
    endif
endfunction

function! LjyatShowCscopeTags(tag)
    if &ft == "java"
        return -1
    endif

    try
        exe "cs f g " . a:tag
    catch /^Vim\%((\a\+)\)\=:E/
        if v:exception =~ "E259"
            call s:EchoWarningMsg("not found tag: " . a:tag)
        elseif v:exception =~ "E567"
            call s:EchoWarningMsg("no cscope connection !!!")
        endif
        return -1
    endtry
endfunction

function! LjyatShowTags(word)
    let word = a:word
    let use_cscope = 0

    call s:EchoMoreMsg(word)

    silent! let tlist = taglist('\<'. word . '\>')
    if empty(tlist)
        let use_cscope = 1
    endif

    for item in tlist
        if item['cmd'] =~ s:ignore_match_tag
            let use_cscope = 1
        endif
    endfor

    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            return
        endif
    else
        " see LjyatShowTagInPreview()
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                return
            endif
        endtry
    endif
    normal zz
endfunction

function! LjyatShowTagInPreview(word)
    let word = a:word
    let use_cscope = 0
    call s:EchoMoreMsg(word)

    silent! let tlist = taglist('\<'. word . '\>')
    for item in tlist
        if item['cmd'] =~ s:ignore_match_tag
            let use_cscope = 1
        endif
	endfor

    let pw_exist = 0
    let win_cur = winnr()
    silent! wincmd P
    if &previewwindow
        let pw_exist = 1
    else
        silent! pedit
        let win_cur = winnr()
    endif

    wincmd P
    if use_cscope
        if LjyatShowCscopeTags(word) == -1
            exe win_cur . "wincmd w"
            if !pw_exist
                pclose
            endif
            return
        endif
    else
        " some time don't get tag, but taglist() can get, this maybe a bug
        " I have know this problem, because pattern with xxx$ in tags file
        " with dos format, vim can't got it with / or ? , so skip with cscope.
        " Haha, this maybe is ctags problem, it doesn't matter.
        try
            exe "tjump " . word
        catch /^Vim\%((\a\+)\)\=:E/
            if v:exception =~ "E432"
                return
            endif
            if LjyatShowCscopeTags(word) == -1
                exe win_cur . "wincmd w"
                if !pw_exist
                    pclose
                endif
                return
            endif
        endtry
    endif
    silent! call matchdelete(s:PreviewTagID)
    let s:PreviewTagID = matchadd('PreviewTagGroup', '\<' . word . '\>')
    if getline('.') =~ '^#define .\+[^\\]$\|;'
        normal zz
    else
        normal zt
    endif

    exe win_cur . "wincmd w"
endfunction
"============= show preview tag config end ===========

function! CompleteCurlyBrackets()
    if (getline('.')[col('.'):] =~'^\s*$')
        put = 'x'
        put = '}'
        normal =%j
        exe "s/x//"
        startinsert!
    else
        let l:col = col('.')
        exe "s/\\%" . l:col . "c{/{}/"
        call cursor('.', l:col + 1)
        startinsert
    endif
endfunction

function! LjyatNERDTreeOpenBufDir()
    call LjyatSkipSpecWindow()
    if (exists("t:NERDTreeBufName"))
        if (bufwinnr(t:NERDTreeBufName) != -1)
            execute "silent! NERDTreeClose"
            return
        endif
    endif
    let l:bufname = escape(bufname("%"), ' #')
    execute "silent! NERDTree " . l:bufname
    redraw!
endfunction

"=> cscope set
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=1
    set nocst
    " add any database in current directory
    if filereadable("cscope.out")
        silent! cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
endif

function! CleanTmpListFile()
    if filereadable(s:tmpcscope_files)
        execute "silent! !rm -rf " . s:tmpcscope_files
    endif
endfunction

function! TagDirs()
    let dirs = join(s:cscope_tag_dir_list, ",")
    if dirs == ''
        return ''
    else
        return '['.dirs.']'
    endif
endfunction

function! InitTagDirs()
    silent exe "cs kill -1"
    call CleanTmpListFile()
    let &tags=''
    let &dict=''
    let s:tmpcscope_files = ''
    let s:cscope_tag_dir_list = []
endfunction

function! RemoveTagDirs(rmdirs)
    if a:rmdirs == ''
        call InitTagDirs()
        redraw!
        return
    endif

    let newlist = copy(s:cscope_tag_dir_list)
    for dir in split(a:rmdirs, ",")
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        let rm_tag          = dir . "/tags"
        let rm_cscope       = dir . "/cscope.out"

        if !filereadable(rm_tag) || !filereadable(rm_cscope)
            call s:EchoWarningMsg("empty dir: " . dir)
            redraw!
            return
        endif
        call filter(newlist, 'v:val != dir')
    endfor
    call InitTagDirs()
    if len(newlist) != 0
        call AddTagDirs(join(newlist, ','))
    else
        redraw!
    endif
endfunction

function! AnyOneInTagDirList(dirlist)
    let filelist = copy(s:cscope_tag_dir_list)
    for dir in a:dirlist
        if s:cscope_tag_dir_list != filter(filelist, 'v:val != dir')
            return 1
        endif
    endfor
    return 0
endfunction

function! AddTagDirs(predirs)
    if a:predirs == ''
        call s:EchoWarningMsg("need tag dir")
        return
    endif

    let arglist = []
    for dir in split(a:predirs, ",")
        call add(arglist, substitute(expand(split(dir, "\"")[0]),'/$', '',''))
    endfor
    call uniq(sort(arglist))

    if AnyOneInTagDirList(arglist)
        let addedlist = uniq(sort(arglist + s:cscope_tag_dir_list))
        call InitTagDirs()
    else
        let addedlist = arglist
    endif

    if s:tmpcscope_files == ''
        let s:tmpcscope_files = "/tmp/cscope.files." . getpid()
    endif
    for dir in addedlist
        let dir = substitute(expand(split(dir, "\"")[0]),'/$', '','')
        if dir == '.'
            let new_tag_path     = "tags"
            let new_cscope_path  = "cscope.out"
            let new_dict_path    = "dict"
            let new_cscope_files = "cscope.files"
        else
            let new_cscope_path  = dir . "/cscope.out"
            let new_tag_path     = dir . "/tags"
            let new_dict_path    = dir . "/dict"
            let new_cscope_files = dir . "/cscope.files"
        endif

        if !filereadable(new_tag_path) || !filereadable(new_cscope_path)
            call s:EchoWarningMsg("No needed file in: " . dir)
            return
        endif

        if filereadable(new_cscope_files)
            if dir == '.'
                silent exe "!cat " . new_cscope_files . ' >> ' . s:tmpcscope_files
            else
                silent exe "!cat " . new_cscope_files . "|sed 's:^:" . dir . "/:' >> " . s:tmpcscope_files
            endif
        endif

        if len(s:cscope_tag_dir_list) == 0
            let &tags = new_tag_path
            let &dict = new_dict_path
        else
            let &tags = &tags . "," . new_tag_path
            let &dict = &dict . "," . new_dict_path
        endif
        call add(s:cscope_tag_dir_list, dir)

        "cscope prepath always need a '/'
        if stridx(dir, "/") == -1
            let dir = substitute(dir, '^', './','')
        endif
        silent! exe "cscope add " . new_cscope_path . " " . dir
    endfor
    redraw!
endfunction

function! LjyatSearchTags()
    echohl Question
    let pattern = input("  Search tag: ")
    echohl None

    if pattern == ""
        return
    endif

    try
        execute "tj /" . pattern
    catch /^Vim\%((\a\+)\)\=:E/
        call s:EchoWarningMsg("not found tag: " . pattern)
    endtry
endfunction

function! Arggrep(pattern_arg)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern_arg == ''
        call s:EchoWarningMsg("pattern is null")
        return
    endif

    execute "silent! MarkClear|silent! Mark " . a:pattern_arg

    let pattern_arg = "'" . a:pattern_arg . "'"
    let real_cmd = 'cat ' . s:tmpcscope_files .' |xargs grep -n -E ' . pattern_arg
    call s:EchoMoreMsg("Searching all-str ...")

    let match_string = system(real_cmd)
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern_arg)
        return
    endif

    let old = ''
    let new = ''
    let match_files = ''
    for line in split(match_string, '\n')
        let new = substitute(line, ':.*', '', 'g')
        if old != new
            let match_files = match_files . " " . new
        endif
        let old = new
    endfor
    exec "args " . match_files

    let ef = &errorformat
    set efm=%f:%l:%m

    let matchlist = split(match_string, '\n')
    let matchlen = len(matchlist)
    execute "lexpr matchlist"
    lopen
    let &errorformat=ef
    call s:EchoMoreMsg(matchlen . " matches for " . pattern_arg )
endfunction

function! LjyatSearchFunctionCaller()
    let pattern = expand("<cword>")
    if pattern == ""
        return
    endif

    let pattern = '=\s*\<' . pattern . '\>|\<' . pattern . '\>\s*\('
    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. s:tmpcscope_files . '|xargs grep -n -E ' . pattern
    call s:EchoMoreMsg("Searching caller-str...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    redraw
endfunction

function! LjyatSearchStringInFiles(pattern_arg)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    echohl Question
    if a:pattern_arg != ''
        let pattern = input("  Search all-str: ", a:pattern_arg)
    else
        let pattern = input("  Search all-str: ", escape(expand("<cword>"), '#'))
    endif
    echohl None

    if pattern == ""
        return
    endif

    let pattern = "'" . pattern . "'"
    let real_cmd = 'cat '. s:tmpcscope_files . '|xargs grep -n -E ' . pattern
    call s:EchoMoreMsg("Searching all-str...")
    let match_string = system(real_cmd, "\n")
    if match_string == ""
        call s:EchoWarningMsg("No match string: " . pattern)
        return
    endif

    let matchlist = split(match_string, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m

    execute "lexpr match_string"
    lopen
    let &errorformat=ef
    call s:EchoMoreMsg(matchlen . " matches for " . pattern )
endfunction

function! Argfind(pattern)
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    if a:pattern == ''
        echo "   pattern is null"
        return
    endif

    let pattern = "'" . a:pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching file...")
    let match_files = system(real_cmd, " ")
    if match_files == ""
        call s:EchoWarningMsg("No match file: " . pattern)
        return
    endif

    let args_file = ""
    for line in split(match_files, '\n')
        let args_file = args_file . " " . line
    endfor
    exec "args " . args_file
    let ef = &errorformat
    set efm=%f

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    execute "lexpr matchlist"
    lopen
    let &errorformat=ef
    call s:EchoMoreMsg(matchlen . " matches for " . pattern)
endfunction

function! LjyatSearchFileInFileList()
    if !filereadable(s:tmpcscope_files)
        call s:EchoWarningMsg("cscope.files not exist")
        return
    endif

    echohl Question
    let pattern = input("  Search file: ")
    echohl None

    if pattern == ""
        return
    endif

    let pattern = "'" . pattern . "'"
    let real_cmd = 'grep  -i -E ' . pattern . ' ' . s:tmpcscope_files
    call s:EchoMoreMsg("Searching file...")

    let match_files = system(real_cmd)
    if match_files == ""
        call s:EchoWarningMsg("No match files: " . pattern)
        return
    endif

    let matchlist = split(match_files, '\n')
    let matchlen = len(matchlist)
    if matchlen > g:SearchLimit
        call s:EchoMoreMsg("match " . matchlen . " > " . g:SearchLimit . " items, change pattern please ")
        return
    endif

    let ef = &errorformat
    set efm=%f

    execute "silent! lexpr match_files"

    lopen
    let &errorformat = ef
    redraw!
    call s:EchoMoreMsg(matchlen . " matches for " . pattern )
endfunction

function! LjyatSkipSpecWindow()
    let win_count = winnr('$') "loop back to this window again
    let win_pos = 0
    while &buftype != ""
        if win_pos == win_count
            break
        endif
        let win_pos = win_pos + 1
        wincmd w
    endwhile
endfunction

"<C-s> not work in terminal. so should use <F4>
function! LjyatSearchStringCurrentBuffer()
    call LjyatSkipSpecWindow()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    echohl Question

    if len(s:SearchList) == 0
        let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
        endif
    else
        let outputlist = []
        call add(outputlist, '0. ' . expand("<cword>"))
        let idx = 1
        for item in s:SearchList
            let outputitem = idx . '. ' . item
            call add(outputlist, outputitem)
            let idx += 1
        endfor

        let l:sel_idx = inputlist(outputlist)
        if l:sel_idx == 0
            let s:StrPattern = input("  Search cur-str: ", expand("<cword>"))
        else
            let s:StrPattern = input("  Search cur-str: ", s:SearchList[l:sel_idx - 1])
        endif
        if match(s:StrPattern, "\|")  != -1
            call insert(s:SearchList, s:StrPattern)
            let s:SearchList = uniq(copy(s:SearchList))
            if len(s:SearchList) > s:searchhistory
                call remove(s:SearchList, -1)
            endif
        endif
    endif

    echohl None

    if s:StrPattern == ""
        return
    endif

    let l:pattern = "/" . s:StrPattern . "/"
    let real_cmd = "lvimgrep " . l:pattern . " %"
    call s:EchoMoreMsg("Searching cur-str...")
    execute "silent! " . real_cmd
    lopen
    redraw!
endfunction

function! LjyatVSearchStringCurrentBuffer()
    let curfilename = expand("%")
    if curfilename == ""
        call s:EchoWarningMsg("buffer name is NULL")
        return
    endif

    let old = @"
    exe "normal! gvy"
    let pattern = @"
    let @" = old

    let pattern = input("  Search cur-str: ", pattern)

    let pattern = "/" . pattern . "/"
    let real_cmd = "lvimgrep " . pattern . " %"
    execute "silent! " . real_cmd

    lopen
    redraw!
endfunction

function! LjyatVSearchStringInFiles()
    let old = @"
    exe "normal! gvy"
    let pattern = @"
    call LjyatSearchStringInFiles(pattern)
    let @" = old
    redraw!
endfunction

function! SwitchTlistTagbar()
    let tagbarwinnr = bufwinnr("__Tagbar__")
    let tlistwinnr = bufwinnr(g:TagList_title)

    if tagbarwinnr != -1
        TagbarToggle
        if tlistwinnr == -1
            Tlist
        endif
    elseif tlistwinnr != -1
        Tlist
        if tagbarwinnr == -1
            TagbarToggle
        endif
    else
        Tlist
    endif
endfunction

function! IncreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size += 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size += 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! DecreaseFontSize()
    if has("gui_running")
        let oldft=&guifont
        if has("win32")
            let font_size=matchstr(oldft, ':h\zs\d\+')
            let font_size -= 1
            let &guifont = substitute(oldft, ':h\zs\d\+', font_size, '')
        else
            let font_size = matchstr(oldft, '\d\+$')
            let font_size -= 1
            let &guifont = substitute(oldft, '\d\+$', font_size, '')
        endif
    endif
endfunction

function! CreateTable(linenum, col)
    let c=a:col
    let l = a:linenum
    let empty_str = " "
    while c > 0
        let empty_str = empty_str . " "
        let c = c - 1
    endwhile

    while l > 0
        put =empty_str
        let l = l - 1
    endwhile
endfunction

let s:mark_index = 0
let s:mark_list=[]
function! LjyatAddBookMark()
    let s:mark_tag_{s:mark_index} = bufname('%'). ":". line('.') .":".getline('.')
    let s:mark_list+=[s:mark_tag_{s:mark_index}]
    let s:mark_index+=1
endfunction

function! LjyatShowBookMarks()
    if s:mark_index == 0
        call s:EchoWarningMsg("No marks ")
        return
    endif

    let ef = &errorformat
    set efm=%f:%l:%m
    exe "cgetexpr s:mark_list"
    exe "botright copen"
    let &errorformat = ef
endfunction

function! LjyatBookMarkClear()
    let s:mark_index = 0
    let s:mark_list=[]
    execute "cclose"
endfunction

function! LjyatFoldToggle()
    if &foldcolumn == 0
        let &foldcolumn = 4
        let &foldmethod = 'syntax'
        let &foldlevel = 2
        set foldenable
    else
        let &foldcolumn = 0
        let &foldmethod = 'manual'
        let &foldlevel = 99
        set nofoldenable
    endif
endfunction

function! AlignPattern()
    let input = input("  Align: ", '=')
    let str = escape(input, '.')
    let line_s = line("'<")
    let line_e = line("'>")
    let max = 0
    let arr = {}
    let l = line_s
    while l <= line_e
        let line = getline(l)
        if matchstr(line, str) == ''
            let l += 1
            continue
        endif
        let arr[l] = matchlist(getline(l), '\(^.*\)' . str . '\(.*\)')
        let len = strlen(arr[l][1])
        let max = (len > max ? len : max)
        let l += 1
    endwhile

    let strSpace = CreateSpaces(max)
    for [key, value] in items(arr)
        call setline(key, value[1].strpart(strSpace, 0, max-strlen(value[1])) . input . value[2])
    endfor
endfunction

function! CreateSpaces(n)
    let s = ''
    for i in range(a:n)
        let s .= ' '
    endfor
    return s
endfunction

command! -nargs=1 Argfind call Argfind(<f-args>)
command! -nargs=+ -complete=dir A call AddTagDirs('<f-args>')
command! -nargs=* -complete=dir R call RemoveTagDirs('<f-args>')
command! -nargs=0  S echo TagDirs()
command! LjyatNERDTreeOpenBufDir call LjyatNERDTreeOpenBufDir ()
command! -nargs=1 Arggrep call Arggrep(<f-args>)
command! LjyatSearchStringInFiles call LjyatSearchStringInFiles('')
command! LjyatSearchFunctionCaller call LjyatSearchFunctionCaller()
command! LjyatSearchFileInFileList call LjyatSearchFileInFileList()
command! LjyatVSearchStringCurrentBuffer call LjyatVSearchStringCurrentBuffer()
command! LjyatSearchStringCurrentBuffer call LjyatSearchStringCurrentBuffer()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatAddBookMark call LjyatAddBookMark()
command! LjyatShowBookMarks call LjyatShowBookMarks()
command! LjyatBookMarkClear call LjyatBookMarkClear()
command! -nargs=+ CreateTable call CreateTable(<f-args>)

" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup LjyatAutoCmds
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
    autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType htm set omnifunc=htmlcomplete#CompleteTags
    autocmd FileType css set omnifunc=csscomplete#CompleteCSS
    autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
    autocmd FileType php set omnifunc=phpcomplete#CompletePHP
    autocmd FileType c,cpp,java,cs set omnifunc=ccomplete#Complete
    autocmd FileType make setlocal iskeyword+=-
    autocmd FileType qf setlocal nowrap nu
    autocmd VimEnter * call AddTagDirs('.')

    autocmd VimLeave * call CleanTmpListFile()
    autocmd BufNewFile,BufRead *.aidl setf java
augroup end
" => Set OminComplete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" => Set mark color
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
hi MarkWord1  ctermbg=Cyan     ctermfg=Black  guibg=#8CCBEA    guifg=Black
hi MarkWord2  ctermbg=Green    ctermfg=Black  guibg=#A4E57E    guifg=Black
hi MarkWord3  ctermbg=Yellow   ctermfg=Black  guibg=#FFDB72    guifg=Black
hi MarkWord4  ctermbg=Red      ctermfg=Black  guibg=#FF7272    guifg=Black
hi MarkWord5  ctermbg=Magenta  ctermfg=Black  guibg=#FFB3FF    guifg=Black
hi MarkWord6  ctermbg=Blue     ctermfg=Black  guibg=#9999FF    guifg=Black
